---
title: PRELIMINARES
jupyter: python3
---



```{python}
#| colab: {base_uri: https://localhost:8080/}
# Instalamos librer√≠as b√°sicas para conectarnos a la API y manipular datos
%pip install -q requests pandas scikit-learn networkx matplotlib

# Importamos los m√≥dulos que usaremos
import os, time, math, requests, pandas as pd, numpy as np
import networkx as nx
import matplotlib.pyplot as plt

# Pedimos al usuario su clave API (una sola vez)
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY") or input("üîë Pega tu GOOGLE_API_KEY: ").strip()
```

MOTELES

```{python}
def gmaps_text_search(query="Motel", lat=4.7110, lon=-74.0721, radius=30000, region="co", max_pages=40, sleep_s=10.0):
    url = "https://maps.googleapis.com/maps/api/place/textsearch/json"
    params = {
        "query": query,
        "location": f"{lat},{lon}",
        "radius": radius,
        "region": region,
        "key": GOOGLE_API_KEY
    }
    rows, page = [], 0
    while page < max_pages:
        r = requests.get(url, params=params, timeout=30)
        data = r.json()

        # Si hubo error, lo mostramos y detenemos
        if data.get("status") not in ("OK", "ZERO_RESULTS"):
            print("Error:", data.get("status"), data.get("error_message"))
            break

        # Extraemos la informaci√≥n de cada lugar
        for p in data.get("results", []):
            rows.append({
                "id_lugar": p.get("place_id"),
                "nombre": p.get("name"),
                "rating": p.get("rating"),
                "rese√±as": p.get("user_ratings_total"),
                "rango_precio": p.get("price_level"),
                "lat": p.get("geometry", {}).get("location", {}).get("lat"),
                "lon": p.get("geometry", {}).get("location", {}).get("lng"),
                "direccion": p.get("formatted_address"),
                "tipo": ",".join(p.get("types", [])),
                "estado_negocio": p.get("business_status")
            })

        # Si hay m√°s resultados, esperamos y pedimos la siguiente p√°gina
        nxt = data.get("next_page_token")
        if not nxt:
            break
        time.sleep(sleep_s)
        params = {"pagetoken": nxt, "key": GOOGLE_API_KEY}
        page += 1

    return pd.DataFrame(rows)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
df_moteles = gmaps_text_search(query="Motel""motel", max_pages=41)
df_moteles.shape, df_moteles.head(30)
```

```{python}
#| collapsed: true
# Guardar datos
# Guardar en un archivo CSV
df_moteles.to_csv("Moteles_Final.csv", index=False, encoding="utf-8")
```

BURDEL

```{python}
def gmaps_text_search(query="Prostibulo", lat=4.7110, lon=-74.0721, radius=30000, region="co", max_pages=40, sleep_s=10.0):
    url = "https://maps.googleapis.com/maps/api/place/textsearch/json"
    params = {
        "query": query,
        "location": f"{lat},{lon}",
        "radius": radius,
        "region": region,
        "key": GOOGLE_API_KEY
    }
    rows, page = [], 0
    while page < max_pages:
        r = requests.get(url, params=params, timeout=30)
        data = r.json()

        # Si hubo error, lo mostramos y detenemos
        if data.get("status") not in ("OK", "ZERO_RESULTS"):
            print("Error:", data.get("status"), data.get("error_message"))
            break

        # Extraemos la informaci√≥n de cada lugar
        for p in data.get("results", []):
            rows.append({
                "id_lugar": p.get("place_id"),
                "nombre": p.get("name"),
                "rating": p.get("rating"),
                "rese√±as": p.get("user_ratings_total"),
                "rango_precio": p.get("price_level"),
                "lat": p.get("geometry", {}).get("location", {}).get("lat"),
                "lon": p.get("geometry", {}).get("location", {}).get("lng"),
                "direccion": p.get("formatted_address"),
                "tipo": ",".join(p.get("types", [])),
                "estado_negocio": p.get("business_status")
            })

        # Si hay m√°s resultados, esperamos y pedimos la siguiente p√°gina
        nxt = data.get("next_page_token")
        if not nxt:
            break
        time.sleep(sleep_s)
        params = {"pagetoken": nxt, "key": GOOGLE_API_KEY}
        page += 1

    return pd.DataFrame(rows)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
df1 = gmaps_text_search(query="prost√≠bulo", max_pages=41)
df2 = gmaps_text_search(query="prostibulo", max_pages=41)
df3 = gmaps_text_search(query="Prost√≠bulo", max_pages=41)
df4 = gmaps_text_search(query="Prostibulo", max_pages=41)
df5 = gmaps_text_search(query="Burdel", max_pages=41)
df6 = gmaps_text_search(query="burdel", max_pages=41)
df7 = gmaps_text_search(query="Puteadero", max_pages=41)
df8 = gmaps_text_search(query="puteadero", max_pages=41)

df_burdel = pd.concat([df1, df2, df3, df4, df5, df6, df7, df8]).drop_duplicates().reset_index(drop=True)
df_burdel.shape
print(df_burdel)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
# Guardar datos
# Guardar en un archivo CSV
df_burdel.to_csv("Burdel_Final.csv", index=False, encoding="utf-8")
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJh4haQhd5P44Rn7lSquE6f8o"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJPVDeUV-HP44Rrf0x1rQXjhA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJ9VrAAlqnMI4RUeDSfew1mKg"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJpSe6UOsvPo4Rwr_6YAFGPEU"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJmRV1Rl2mMI4RgFMlk1P2Ae4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJzebdbgauKIQRgmESxdUPwpM"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJO129iJApRI4R6-m82Lp8EL4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJv0qjX4WmMI4RQq8f_S8Vpc4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJree8KeanMI4R6Y7rEbkd_r0"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJm1P1nQouPo4R3ECNPcBsSDA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJcZ0NLCynMI4RZntyNjoIJA4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJl-NMiyKmMI4RiXSpjMwZ4dA"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJl3JggxSmMI4Re4SW-nOPFzA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJj4iM5cIFP44R_JKTzOW17lY"]
df_burdel.head(54)

df_burdel.to_csv("Burdel_Final.csv", index=False, encoding="utf-8")
df_burdel.shape
```

## LIBRER√çAS

```{python}
import os
import time
import requests
import numpy as np
import pandas as pd
import networkx as nx
from sklearn.neighbors import NearestNeighbors
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import networkx as nx
import matplotlib.cm as cm
import matplotlib.colors as colors

# Si luego quieres usar mapas
import folium
from folium.plugins import MarkerCluster

# Opcional, si vas a usar shapefiles de zonas normativas
# import geopandas as gpd
# from shapely.geometry import Point
```

# BASE DE MOTELES

### Base real

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true

# Cargamos los datos locales (exportados o descargados de Google Places)
df_moteles = pd.read_csv("Moteles_Final.csv")
df_moteles["Tipo"] = "M"
df_moteles = df_moteles[df_moteles["rating"] != "NaN"]
df_moteles = df_moteles[df_moteles["rese√±as"] > 5]
print(df_moteles.shape)
print(df_moteles.head(40))


#| echo: true
#| output: true
#| eval: false
coords_moteles = np.radians(df_moteles[["lat", "lon"]].dropna().to_numpy())
```

### Grafos

#### 4 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 4 # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_moteles)
dist, idx = nbrs.kneighbors(coords_moteles)

G_motel_4 = nx.Graph()
for i, row in df_moteles.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_motel_4.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_moteles)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_motel_4.add_edge(i, j, weight=d_km)

x = (df_moteles["lon"] - df_moteles["lon"].min()) / (df_moteles["lon"].max() - df_moteles["lon"].min())
y = (df_moteles["lat"] - df_moteles["lat"].min()) / (df_moteles["lat"].max() - df_moteles["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_motel_4, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de moteles en Bogot√° (4 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

#### 6 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 6  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_moteles)
dist, idx = nbrs.kneighbors(coords_moteles)

G_motel_6 = nx.Graph()
for i, row in df_moteles.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_motel_6.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_moteles)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_motel_6.add_edge(i, j, weight=d_km)

x = (df_moteles["lon"] - df_moteles["lon"].min()) / (df_moteles["lon"].max() - df_moteles["lon"].min())
y = (df_moteles["lat"] - df_moteles["lat"].min()) / (df_moteles["lat"].max() - df_moteles["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_motel_6, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de moteles en Bogot√° (6 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

#### 8 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 8  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_moteles)
dist, idx = nbrs.kneighbors(coords_moteles)

G_motel_8 = nx.Graph()
for i, row in df_moteles.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_motel_8.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_moteles)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_motel_8.add_edge(i, j, weight=d_km)

x = (df_moteles["lon"] - df_moteles["lon"].min()) / (df_moteles["lon"].max() - df_moteles["lon"].min())
y = (df_moteles["lat"] - df_moteles["lat"].min()) / (df_moteles["lat"].max() - df_moteles["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_motel_8, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de moteles en Bogot√° (8 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

### Mapa

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 310}
#| collapsed: true
import folium

# 1Ô∏è‚É£ Crear el mapa base centrado en Bogot√°
m = folium.Map(location=[4.65, -74.07], zoom_start=12)
# 2Ô∏è‚É£ Funci√≥n para asignar color seg√∫n el rating
def color_rating(rating):
    if rating >= 4.5:
        return "green"       # excelente ‚òòÔ∏è
    elif rating >= 3.5:
        return "orange"      # bueno ‚òï
    else:
        return "red"         # bajo üò¨
# 3Ô∏è‚É£ Agregar cada caf√© como marcador circular
for _, r in df_moteles.iterrows():
    folium.CircleMarker(
        location=[r.lat, r.lon],
        radius=6,
        color=color_rating(r.rating),      # borde del c√≠rculo
        fill=True,
        fill_color=color_rating(r.rating), # color interno
        fill_opacity=0.85,
        popup=f"{r['nombre']} ‚≠ê{r['rating']} ({r['rese√±as']} rese√±as)"
    ).add_to(m)
m
```

#### Mapa por proximidad

```{python}
#| collapsed: true
#| colab: {base_uri: https://localhost:8080/, height: 310}
# Mapa centrado en Bogot√°
m = folium.Map(location=[4.65, -74.07], zoom_start=11)

cluster = MarkerCluster().add_to(m)

for _, row in df_moteles.iterrows():
    popup = f"{row['nombre']}<br>Rating: {row['rating']}"
    folium.Marker(
        location=[row["lat"], row["lon"]],
        popup=popup
    ).add_to(cluster)

m
```

# BASE BURDELES

## Base real

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
# Cargamos los datos locales (exportados o descargados de Google Places)
df_burdel = pd.read_csv("Burdel_Final.csv")

# Guardar datos
# Guardar en un archivo CSV
df_burdel.to_csv("Burdel_Final.csv", index=False, encoding="utf-8")
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJh4haQhd5P44Rn7lSquE6f8o"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJPVDeUV-HP44Rrf0x1rQXjhA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJ9VrAAlqnMI4RUeDSfew1mKg"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJpSe6UOsvPo4Rwr_6YAFGPEU"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJmRV1Rl2mMI4RgFMlk1P2Ae4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJzebdbgauKIQRgmESxdUPwpM"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJO129iJApRI4R6-m82Lp8EL4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJv0qjX4WmMI4RQq8f_S8Vpc4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJree8KeanMI4R6Y7rEbkd_r0"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJm1P1nQouPo4R3ECNPcBsSDA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJcZ0NLCynMI4RZntyNjoIJA4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJl-NMiyKmMI4RiXSpjMwZ4dA"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJl3JggxSmMI4Re4SW-nOPFzA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJj4iM5cIFP44R_JKTzOW17lY"]

df_burdel["Tipo"] = "B"
df_burdel = df_burdel.drop_duplicates()
df_burdel = df_burdel[df_burdel["rating"] != "NaN"]
df_burdel = df_burdel[df_burdel["rese√±as"] > 5]
print(df_burdel.shape)
print(df_burdel.head(3))

#| echo: true
#| output: true
#| eval: false
coords_burdel = np.radians(df_burdel[["lat", "lon"]].dropna().to_numpy())
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
#| collapsed: true
df_burdel.head(53)
```

## Grafos

### 4 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 4  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_burdel)
dist, idx = nbrs.kneighbors(coords_burdel)

G_burdel_4 = nx.Graph()
for i, row in df_burdel.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_burdel_4.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_burdel)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_burdel_4.add_edge(i, j, weight=d_km)

x = (df_burdel["lon"] - df_burdel["lon"].min()) / (df_burdel["lon"].max() - df_burdel["lon"].min())
y = (df_burdel["lat"] - df_burdel["lat"].min()) / (df_burdel["lat"].max() - df_burdel["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_burdel_4, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de Burdeles en Bogot√° (4 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

### 6 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
k = 6  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_burdel)
dist, idx = nbrs.kneighbors(coords_burdel)

G_burdel_6 = nx.Graph()
for i, row in df_burdel.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_burdel_6.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_burdel)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_burdel_6.add_edge(i, j, weight=d_km)

x = (df_burdel["lon"] - df_burdel["lon"].min()) / (df_burdel["lon"].max() - df_burdel["lon"].min())
y = (df_burdel["lat"] - df_burdel["lat"].min()) / (df_burdel["lat"].max() - df_burdel["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_burdel_6, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de Burdeles en Bogot√° (6 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

### 8 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 8  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_burdel)
dist, idx = nbrs.kneighbors(coords_burdel)

G_burdel_8 = nx.Graph()
for i, row in df_burdel.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_burdel_8.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_burdel)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_burdel_8.add_edge(i, j, weight=d_km)

x = (df_burdel["lon"] - df_burdel["lon"].min()) / (df_burdel["lon"].max() - df_burdel["lon"].min())
y = (df_burdel["lat"] - df_burdel["lat"].min()) / (df_burdel["lat"].max() - df_burdel["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_burdel_8, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de Burdeles en Bogot√° (8 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

## Mapa

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 310}
#| collapsed: true
# 1Ô∏è‚É£ Crear el mapa base centrado en Bogot√°
m = folium.Map(location=[4.65, -74.07], zoom_start=12)
# 2Ô∏è‚É£ Funci√≥n para asignar color seg√∫n el rating
def color_rating(rating):
    if rating >= 4.5:
        return "green"       # excelente ‚òòÔ∏è
    elif rating >= 3.5:
        return "orange"      # bueno ‚òï
    else:
        return "red"         # bajo üò¨
# 3Ô∏è‚É£ Agregar cada caf√© como marcador circular
for _, r in df_burdel.iterrows():
    folium.CircleMarker(
        location=[r.lat, r.lon],
        radius=6,
        color=color_rating(r.rating),      # borde del c√≠rculo
        fill=True,
        fill_color=color_rating(r.rating), # color interno
        fill_opacity=0.85,
        popup=f"{r['nombre']} ‚≠ê{r['rating']} ({r['rese√±as']} rese√±as)"
    ).add_to(m)
m
```

### Mapa de proximidad

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 310}
#| collapsed: true
# Mapa centrado en Bogot√°
m = folium.Map(location=[4.65, -74.07], zoom_start=11)

cluster = MarkerCluster().add_to(m)

for _, row in df_burdel.iterrows():
    popup = f"{row['nombre']}<br>Rating: {row['rating']}"
    folium.Marker(
        location=[row["lat"], row["lon"]],
        popup=popup
    ).add_to(cluster)

m
```

# 18+

## Data conjunto

```{python}
#| collapsed: true
df_completo = pd.concat([df_moteles, df_burdel], ignore_index=True)
df_completo.to_csv("df_completo.csv", index=False, encoding="utf-8")
df_completo.shape
df_completo.head(3)
coords_completo = np.radians(df_completo[["lat", "lon"]].dropna().to_numpy())
```

## Grafos

### 4 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 4  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_completo)
dist, idx = nbrs.kneighbors(coords_completo)

G_completo_4 = nx.Graph()
for i, row in df_completo.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_completo_4.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_completo)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_completo_4.add_edge(i, j, weight=d_km)

x = (df_completo["lon"] - df_completo["lon"].min()) / (df_completo["lon"].max() - df_completo["lon"].min())
y = (df_completo["lat"] - df_completo["lat"].min()) / (df_completo["lat"].max() - df_completo["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_completo_4, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de +18 en Bogot√° (4 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

### 6 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
k = 6  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_completo)
dist, idx = nbrs.kneighbors(coords_completo)

G_completo_6 = nx.Graph()
for i, row in df_completo.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_completo_6.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_completo)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_completo_6.add_edge(i, j, weight=d_km)

x = (df_completo["lon"] - df_completo["lon"].min()) / (df_completo["lon"].max() - df_completo["lon"].min())
y = (df_completo["lat"] - df_completo["lat"].min()) / (df_completo["lat"].max() - df_completo["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_completo_6, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de +18 en Bogot√° (6 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

### 8 vecinos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 444}
#| collapsed: true
k = 8  # n√∫mero de vecinos cercanos
nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine").fit(coords_completo)
dist, idx = nbrs.kneighbors(coords_completo)

G_completo_8 = nx.Graph()
for i, row in df_completo.dropna(subset=["lat","lon"]).reset_index().iterrows():
    G_completo_8.add_node(i, nombre=row["nombre"], rating=row["rating"])

R = 6371  # radio de la Tierra (km)
for i in range(len(coords_completo)):
    for jpos in idx[i,1:]:
        j = int(jpos)
        d_km = dist[i, np.where(idx[i]==jpos)[0][0]] * R
        G_completo_8.add_edge(i, j, weight=d_km)

x = (df_completo["lon"] - df_completo["lon"].min()) / (df_completo["lon"].max() - df_completo["lon"].min())
y = (df_completo["lat"] - df_completo["lat"].min()) / (df_completo["lat"].max() - df_completo["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

plt.figure(figsize=(6,5))
nx.draw(G_completo_8, pos,
        node_size=30,
        node_color="tomato",
        edge_color="gray",
        with_labels=False)
plt.title("Red de +18 en Bogot√° (8 vecinos m√°s cercanos)")
plt.axis("off")
plt.show()
```

## Mapa

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 310}
#| collapsed: true
# 1Ô∏è‚É£ Crear el mapa base centrado en Bogot√°
m = folium.Map(location=[4.65, -74.07], zoom_start=12)
# 2Ô∏è‚É£ Funci√≥n para asignar color seg√∫n el rating
def color_rating(rating):
    if rating >= 4.5:
        return "green"       # excelente ‚òòÔ∏è
    elif rating >= 3.5:
        return "orange"      # bueno ‚òï
    else:
        return "red"         # bajo üò¨
# 3Ô∏è‚É£ Agregar cada caf√© como marcador circular
for _, r in df_completo.iterrows():
    folium.CircleMarker(
        location=[r.lat, r.lon],
        radius=6,
        color=color_rating(r.rating),      # borde del c√≠rculo
        fill=True,
        fill_color=color_rating(r.rating), # color interno
        fill_opacity=0.85,
        popup=f"{r['nombre']} ‚≠ê{r['rating']} ({r['rese√±as']} rese√±as)"
    ).add_to(m)
m
```

### Mapa de proximidad

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 310}
#| collapsed: true
# Mapa centrado en Bogot√°
m = folium.Map(location=[4.65, -74.07], zoom_start=11)

cluster = MarkerCluster().add_to(m)

for _, row in df_completo.iterrows():
    popup = f"{row['nombre']}<br>Rating: {row['rating']}"
    folium.Marker(
        location=[row["lat"], row["lon"]],
        popup=popup
    ).add_to(cluster)

m
```

# METRICAS

## GENERALES

### Moteles

```{python}
#| colab: {base_uri: https://localhost:8080/}
num_nodes_motel = G_motel_6.number_of_nodes()
num_edges_motel = G_motel_6.number_of_edges()
density_motel = nx.density(G_motel_6)
components_motel = list(nx.connected_components(G_motel_6))
num_components_motel = len(components_motel)

print("Nodos:", num_nodes_motel)
print("Aristas:", num_edges_motel)
print("Densidad:", density_motel)
print("Componentes conexas:", num_components_motel)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
largest_cc_motel = max(components_motel, key=len)
G_cc_motel = G_motel_6.subgraph(largest_cc_motel).copy()

print("Nodos en componente gigante:", G_cc_motel.number_of_nodes())
print("Aristas en componente gigante:", G_cc_motel.number_of_edges())
```

### Burdeles

```{python}
#| colab: {base_uri: https://localhost:8080/}
num_nodes_burdel = G_burdel_6.number_of_nodes()
num_edges_burdel = G_burdel_6.number_of_edges()
density_burdel = nx.density(G_burdel_6)
components_burdel = list(nx.connected_components(G_burdel_6))
num_components_burdel = len(components_burdel)

print("Nodos:", num_nodes_burdel)
print("Aristas:", num_edges_burdel)
print("Densidad:", density_burdel)
print("Componentes conexas:", num_components_burdel)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
largest_cc_burdel = max(components_burdel, key=len)
G_cc_burdel = G_burdel_6.subgraph(largest_cc_burdel).copy()

print("Nodos en componente gigante:", G_cc_burdel.number_of_nodes())
print("Aristas en componente gigante:", G_cc_burdel.number_of_edges())
```

### +18

```{python}
#| colab: {base_uri: https://localhost:8080/}
num_nodes_completo = G_completo_6.number_of_nodes()
num_edges_completo = G_completo_6.number_of_edges()
density_completo = nx.density(G_completo_6)
components_completo = list(nx.connected_components(G_completo_6))
num_components_completo = len(components_completo)

print("Nodos:", num_nodes_completo)
print("Aristas:", num_edges_completo)
print("Densidad:", density_completo)
print("Componentes conexas:", num_components_completo)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
largest_cc_completo = max(components_completo, key=len)
G_cc_completo = G_completo_6.subgraph(largest_cc_motel).copy()

print("Nodos en componente gigante:", G_cc_completo.number_of_nodes())
print("Aristas en componente gigante:", G_cc_completo.number_of_edges())
```

## GRADOS

### Moteles

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
deg_dict_motel = dict(G_motel_6.degree())

deg_df_motel = (pd.Series(deg_dict_motel, name="grado")
            .rename_axis("node_id")
            .reset_index())

# Aseguramos el mismo orden que df y anexamos la columna "grado"
df_reset_motel = df_moteles.dropna(subset=["lat","lon"]).reset_index(drop=True).copy()
df_reset_motel["grado"] = df_reset_motel.index.map(deg_dict_motel).fillna(0).astype(int)

print(df_reset_motel)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 440}
#| collapsed: true
degrees_motel = dict(G_cc_motel.degree())
deg_values_motel = list(degrees_motel.values())

print("Grado medio:", np.mean(deg_values_motel))
print("Grado m√°ximo:", np.max(deg_values_motel))

plt.hist(deg_values_motel, bins=range(1, max(deg_values_motel)+2))
plt.xlabel("Grado")
plt.ylabel("Frecuencia")
plt.title("Distribuci√≥n de grado - Red de moteles (componente gigante)")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
plt.figure(figsize=(7,6))

scatter = plt.scatter(
    df_reset_motel["lon"],
    df_reset_motel["lat"],
    c=df_reset_motel["grado"],
    cmap="viridis",
    s=40,
    edgecolor="black"
)

plt.colorbar(scatter, label="Grado del nodo")
plt.xlabel("Longitud")
plt.ylabel("Latitud")
plt.title("Distribuci√≥n espacial de moteles por grado (densidad de conexiones)")

plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true


deg_dict_motel = dict(G_motel_6.degree())
node_colors = [deg_dict_motel[n] for n in G_motel_6.nodes()]

# Layout
x = (df_reset_motel["lon"] - df_reset_motel["lon"].min()) / (df_reset_motel["lon"].max() - df_reset_motel["lon"].min())
y = (df_reset_motel["lat"] - df_reset_motel["lat"].min()) / (df_reset_motel["lat"].max() - df_reset_motel["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

# --- LA CLAVE ---
fig, ax = plt.subplots(figsize=(7,6))

# Dibujar en ese axis
nx.draw(
    G_motel_6,
    pos,
    node_color=node_colors,
    cmap="viridis",
    node_size=40,
    edge_color="gray",
    with_labels=False,
    ax=ax
)

# Crear mappable
norm = colors.Normalize(vmin=min(node_colors), vmax=max(node_colors))
cmap = cm.viridis
sm = cm.ScalarMappable(norm=norm, cmap=cmap)
sm.set_array([])

# --- ESTA ES LA L√çNEA QUE RESUELVE EL ERROR ---
fig.colorbar(sm, ax=ax, label="Grado del nodo")

ax.set_title("Grafo de moteles coloreado por grado")
ax.set_axis_off()

plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
import seaborn as sns
import matplotlib.pyplot as plt
plt.figure(figsize=(8,6))

sns.countplot(
    x=df_reset_motel["grado"],
    color="firebrick",
    edgecolor="black"
)

plt.xlabel("Grado del nodo")
plt.ylabel("N√∫mero de moteles")
plt.title("Distribuci√≥n del grado en la red de moteles")

plt.show()
```

### Burdeles

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
# Si ya creaste G_cafe con tus aristas k-NN, aqu√≠ obtenemos los grados:
deg_dict_burdel = dict(G_burdel_6.degree())        # {nodo: grado}

# (Opcional) Pasarlo a DataFrame alineado con df:
deg_df_burdel = (pd.Series(deg_dict_burdel, name="grado")
            .rename_axis("node_id")
            .reset_index())

# Aseguramos el mismo orden que df y anexamos la columna "grado"
df_reset_burdel = df_burdel.dropna(subset=["lat","lon"]).reset_index(drop=True).copy()
df_reset_burdel["grado"] = df_reset_burdel.index.map(deg_dict_burdel).fillna(0).astype(int)

print(df_reset_burdel)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
degrees_burdel = dict(G_cc_burdel.degree())
deg_values_burdel = list(degrees_burdel.values())

print("Grado medio:", np.mean(deg_values_burdel))
print("Grado m√°ximo:", np.max(deg_values_burdel))

plt.hist(deg_values_burdel, bins=range(1, max(deg_values_burdel)+2))
plt.xlabel("Grado")
plt.ylabel("Frecuencia")
plt.title("Distribuci√≥n de grado - Red de moteles (componente gigante)")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
plt.figure(figsize=(7,6))

scatter = plt.scatter(
    df_reset_burdel["lon"],
    df_reset_burdel["lat"],
    c=df_reset_burdel["grado"],
    cmap="viridis",
    s=40,
    edgecolor="black"
)

plt.colorbar(scatter, label="Grado del nodo")
plt.xlabel("Longitud")
plt.ylabel("Latitud")
plt.title("Distribuci√≥n espacial de burdeles por grado (densidad de conexiones)")

plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
deg_dict_burdel = dict(G_burdel_6.degree())
node_colors = [deg_dict_burdel[n] for n in G_burdel_6.nodes()]

# Layout
x = (df_reset_burdel["lon"] - df_reset_burdel["lon"].min()) / (df_reset_burdel["lon"].max() - df_reset_burdel["lon"].min())
y = (df_reset_burdel["lat"] - df_reset_burdel["lat"].min()) / (df_reset_burdel["lat"].max() - df_reset_burdel["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

# --- LA CLAVE ---
fig, ax = plt.subplots(figsize=(7,6))

# Dibujar en ese axis
nx.draw(
    G_burdel_6,
    pos,
    node_color=node_colors,
    cmap="viridis",
    node_size=40,
    edge_color="gray",
    with_labels=False,
    ax=ax
)

# Crear mappable
norm = colors.Normalize(vmin=min(node_colors), vmax=max(node_colors))
cmap = cm.viridis
sm = cm.ScalarMappable(norm=norm, cmap=cmap)
sm.set_array([])

# --- ESTA ES LA L√çNEA QUE RESUELVE EL ERROR ---
fig.colorbar(sm, ax=ax, label="Grado del nodo")

ax.set_title("Grafo de burdeles coloreado por grado")
ax.set_axis_off()

plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8,6))

sns.countplot(
    x=df_reset_burdel["grado"],
    color="firebrick",
    edgecolor="black"
)

plt.xlabel("Grado del nodo")
plt.ylabel("N√∫mero de burdeles")
plt.title("Distribuci√≥n del grado en la red de burdeles")

plt.show()
```

### +18

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
# Si ya creaste G_cafe con tus aristas k-NN, aqu√≠ obtenemos los grados:
deg_dict_completo = dict(G_completo_6.degree())        # {nodo: grado}

# (Opcional) Pasarlo a DataFrame alineado con df:
deg_df_completo = (pd.Series(deg_dict_completo, name="grado")
            .rename_axis("node_id")
            .reset_index())

# Aseguramos el mismo orden que df y anexamos la columna "grado"
df_reset_completo = df_completo.dropna(subset=["lat","lon"]).reset_index(drop=True).copy()
df_reset_completo["grado"] = df_reset_completo.index.map(deg_dict_completo).fillna(0).astype(int)

print(df_reset_completo)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 507}
#| collapsed: true
degrees_completo = dict(G_cc_completo.degree())
deg_values_completo = list(degrees_completo.values())

print("Grado medio:", np.mean(deg_values_completo))
print("Grado m√°ximo:", np.max(deg_values_completo))

plt.hist(deg_values_completo, bins=range(1, max(deg_values_completo)+2))
plt.xlabel("Grado")
plt.ylabel("Frecuencia")
plt.title("Distribuci√≥n de grado - Red de +18 (componente gigante)")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 565}
#| collapsed: true
plt.figure(figsize=(7,6))

scatter = plt.scatter(
    df_reset_completo["lon"],
    df_reset_completo["lat"],
    c=df_reset_completo["grado"],
    cmap="viridis",
    s=40,
    edgecolor="black"
)

plt.colorbar(scatter, label="Grado del nodo")
plt.xlabel("Longitud")
plt.ylabel("Latitud")
plt.title("Distribuci√≥n espacial +18 por grado (densidad de conexiones)")

plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 529}
#| collapsed: true
deg_dict_completo = dict(G_completo_6.degree())
node_colors = [deg_dict_completo[n] for n in G_completo_6.nodes()]

# Layout
x = (df_reset_completo["lon"] - df_reset_completo["lon"].min()) / (df_reset_completo["lon"].max() - df_reset_completo["lon"].min())
y = (df_reset_completo["lat"] - df_reset_completo["lat"].min()) / (df_reset_completo["lat"].max() - df_reset_completo["lat"].min())
pos = {i:(xk, yk) for i,(xk, yk) in enumerate(zip(x, y))}

# --- LA CLAVE ---
fig, ax = plt.subplots(figsize=(7,6))

# Dibujar en ese axis
nx.draw(
    G_completo_6,
    pos,
    node_color=node_colors,
    cmap="viridis",
    node_size=40,
    edge_color="gray",
    with_labels=False,
    ax=ax
)

# Crear mappable
norm = colors.Normalize(vmin=min(node_colors), vmax=max(node_colors))
cmap = cm.viridis
sm = cm.ScalarMappable(norm=norm, cmap=cmap)
sm.set_array([])

# --- ESTA ES LA L√çNEA QUE RESUELVE EL ERROR ---
fig.colorbar(sm, ax=ax, label="Grado del nodo")

ax.set_title("Grafo de +18 coloreado por grado")
ax.set_axis_off()

plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 565}
#| collapsed: true
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8,6))

sns.countplot(
    x=df_reset_completo["grado"],
    color="firebrick",
    edgecolor="black"
)

plt.xlabel("Grado del nodo")
plt.ylabel("N√∫mero de burdeles")
plt.title("Distribuci√≥n del grado en +18 de burdeles")

plt.show()
```

# HASTA AQU√ç QUED√ì

## DENSIDAD

### Moteles

```{python}
#| colab: {base_uri: https://localhost:8080/}
densidad_motel = nx.density(G_motel_6)
n = G_motel_6.number_of_nodes()
m = G_motel_6.number_of_edges()

print(f"Nodos: {n} | Aristas: {m} | Densidad: {densidad_motel:.4f}")

# (Extra) Estad√≠sticas r√°pidas de grado
grados_motel = np.fromiter(deg_dict_motel.values(), dtype=int)
print(f"Grado medio: {grados_motel.mean():.2f} | Mediana: {np.median(grados_motel):.0f} | M√°x: {grados_motel.max()}")
```

### Burdel

```{python}
#| colab: {base_uri: https://localhost:8080/}
densidad_burdel = nx.density(G_burdel_6)
n = G_burdel_6.number_of_nodes()
m = G_burdel_6.number_of_edges()

print(f"Nodos: {n} | Aristas: {m} | Densidad: {densidad_burdel:.4f}")

# (Extra) Estad√≠sticas r√°pidas de grado
import numpy as np
grados_burdel = np.fromiter(deg_dict_burdel.values(), dtype=int)
print(f"Grado medio: {grados_burdel.mean():.2f} | Mediana: {np.median(grados_burdel):.0f} | M√°x: {grados_burdel.max()}")
```

### +18

```{python}
#| colab: {base_uri: https://localhost:8080/}
densidad_completo = nx.density(G_completo_6)
n = G_completo_6.number_of_nodes()
m = G_completo_6.number_of_edges()

print(f"Nodos: {n} | Aristas: {m} | Densidad: {densidad_completo:.4f}")

# (Extra) Estad√≠sticas r√°pidas de grado
import numpy as np
grados_completo = np.fromiter(deg_dict_completo.values(), dtype=int)
print(f"Grado medio: {grados_completo.mean():.2f} | Mediana: {np.median(grados_completo):.0f} | M√°x: {grados_completo.max()}")
```

## COMPONENETES CONEXOS

### Moteles

```{python}
#| colab: {base_uri: https://localhost:8080/}
componentes_motel = list(nx.connected_components(G_motel_6))
print(f"Componentes: {len(componentes_motel)}")
for i, comp in enumerate(componentes_motel, start=1):
    print(f" - C{i}: {sorted(comp)}")
```

### Burdel

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
componentes_burdel = list(nx.connected_components(G_burdel_6))
print(f"Componentes: {len(componentes_burdel)}")
for i, comp in enumerate(componentes_burdel, start=1):
    print(f" - C{i}: {sorted(comp)}")
```

### +18

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
componentes_completo = list(nx.connected_components(G_completo_6))
print(f"Componentes: {len(componentes_completo)}")
for i, comp in enumerate(componentes_completo, start=1):
    print(f" - C{i}: {sorted(comp)}")
```

## CENTRALIDADES

### Moteles

```{python}
#| colab: {base_uri: https://localhost:8080/}
c_deg_motel  = nx.degree_centrality(G_motel_6)
c_clo_motel  = nx.closeness_centrality(G_motel_6)          ## cercan√≠a: acceso promedio (ojo con m√∫ltiples componentes)
c_bet_motel  = nx.betweenness_centrality(G_motel_6)        ## intermediaci√≥n: ‚Äúpuentes‚Äù estructurales
print("Centralidad de grado:", c_deg_motel)
print("Centralidad de cercan√≠a:", c_clo_motel)
print("Centralidad de intermediaci√≥n:", c_bet_motel)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 380}
#| collapsed: true
deg_centrality_motel = nx.degree_centrality(G_cc_motel)
close_centrality_motel = nx.closeness_centrality(G_cc_motel, distance="weight")
bet_centrality_motel = nx.betweenness_centrality(G_cc_motel, weight="weight", normalized=True)

# Convertimos a DataFrame para ver los top
cent_df_motel = pd.DataFrame({
    "node": list(G_cc_motel.nodes()),
    "degree_centrality": [deg_centrality_motel[n] for n in G_cc_motel.nodes()],
    "closeness_centrality": [close_centrality_motel[n] for n in G_cc_motel.nodes()],
    "betweenness_centrality": [bet_centrality_motel[n] for n in G_cc_motel.nodes()],
})

# A√±adimos nombre del motel
cent_df_motel["nombre"] = cent_df_motel["node"].apply(lambda n: G_cc_motel.nodes[n]["nombre"])
cent_df_motel.sort_values("betweenness_centrality", ascending=False).head(10)
```

```{python}
#| colab: {base_uri: https://localhost:8080/}
components_motel = list(nx.connected_components(G_motel_6))

for comp in components_motel:
    H = G_motel_6.subgraph(comp)
    print("Nodos:", H.number_of_nodes())
    print("Di√°metro:", nx.diameter(H))
    print("Longitud promedio del camino:", nx.average_shortest_path_length(H))
```

### Burdeles

```{python}
c_deg_burdel  = nx.degree_centrality(G_burdel_6)
c_clo_burdel  = nx.closeness_centrality(G_burdel_6)          ## cercan√≠a: acceso promedio (ojo con m√∫ltiples componentes)
c_bet_burdel  = nx.betweenness_centrality(G_burdel_6)        ## intermediaci√≥n: ‚Äúpuentes‚Äù estructurales
print("Centralidad de grado:", c_deg_burdel)
print("Centralidad de cercan√≠a:", c_clo_burdel)
print("Centralidad de intermediaci√≥n:", c_bet_burdel)
```

```{python}
deg_centrality_burdel = nx.degree_centrality(G_cc_burdel)
close_centrality_burdel = nx.closeness_centrality(G_cc_burdel, distance="weight")
bet_centrality_burdel = nx.betweenness_centrality(G_cc_burdel, weight="weight", normalized=True)

# Convertimos a DataFrame para ver los top
cent_df_burdel = pd.DataFrame({
    "node": list(G_cc_burdel.nodes()),
    "degree_centrality": [deg_centrality_burdel[n] for n in G_cc_burdel.nodes()],
    "closeness_centrality": [close_centrality_burdel[n] for n in G_cc_burdel.nodes()],
    "betweenness_centrality": [bet_centrality_burdel[n] for n in G_cc_burdel.nodes()],
})

# A√±adimos nombre del motel
cent_df_burdel["nombre"] = cent_df_burdel["node"].apply(lambda n: G_cc_burdel.nodes[n]["nombre"])
cent_df_burdel.sort_values("betweenness_centrality", ascending=False).head(10)
```

### +18

```{python}
c_deg_completo  = nx.degree_centrality(G_completo_6)
c_clo_completo  = nx.closeness_centrality(G_completo_6)          ## cercan√≠a: acceso promedio (ojo con m√∫ltiples componentes)
c_bet_completo  = nx.betweenness_centrality(G_completo_6)        ## intermediaci√≥n: ‚Äúpuentes‚Äù estructurales
print("Centralidad de grado:", c_deg_completo)
print("Centralidad de cercan√≠a:", c_clo_completo)
print("Centralidad de intermediaci√≥n:", c_bet_completo)
```

```{python}
deg_centrality_completo = nx.degree_centrality(G_cc_completo)
close_centrality_completo = nx.closeness_centrality(G_cc_completo, distance="weight")
bet_centrality_completo = nx.betweenness_centrality(G_cc_completo, weight="weight", normalized=True)

# Convertimos a DataFrame para ver los top
cent_df_completo = pd.DataFrame({
    "node": list(G_cc_completo.nodes()),
    "degree_centrality": [deg_centrality_completo[n] for n in G_cc_completo.nodes()],
    "closeness_centrality": [close_centrality_completo[n] for n in G_cc_completo.nodes()],
    "betweenness_centrality": [bet_centrality_completo[n] for n in G_cc_completo.nodes()],
})

# A√±adimos nombre del motel
cent_df_completo["nombre"] = cent_df_completo["node"].apply(lambda n: G_cc_completo.nodes[n]["nombre"])
cent_df_completo.sort_values("betweenness_centrality", ascending=False).head(10)
```



## Juntos

```{python}

```





```{python}
import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
from networkx.algorithms import community


def analyze_graph_components(G, graph_name="G", weight_attr="weight", top_n=5):
    """
    Analiza cada componente conexa de un grafo:
    - grado, densidad, tama√±o
    - centralidades: grado, cercan√≠a, betweenness
    - clustering promedio
    - caminos m√°s cortos (ASP, di√°metro)
    - comunidades y modularidad
    - tabla de nodos m√°s centrales
    Adem√°s genera gr√°ficas b√°sicas (histograma de grado, barras de top centrales).
    """
    # Obtener componentes conexas como subgrafos
    components = [G.subgraph(c).copy() for c in nx.connected_components(G)]
    print(f"\n====================== {graph_name} ======================")
    print(f"N√∫mero de componentes conexas: {len(components)}")

    resumen_componentes = []

    for idx, Gi in enumerate(components, start=1):
        comp_name = f"{graph_name}_C{idx}"
        print("\n" + "#"*80)
        print(f"Componente {idx}: {comp_name}")
        print("#"*80)

        n_nodes = Gi.number_of_nodes()
        n_edges = Gi.number_of_edges()
        density = nx.density(Gi)
        avg_degree = 2 * n_edges / n_nodes if n_nodes > 0 else 0

        print(f"Nodos: {n_nodes}")
        print(f"Aristas: {n_edges}")
        print(f"Densidad: {density:.4f}")
        print(f"Grado medio: {avg_degree:.2f}")

        # ¬øTiene peso la arista?
        use_weight = None
        if n_edges > 0:
            # Tomamos una arista cualquiera y miramos si tiene 'weight'
            u, v, data = next(iter(Gi.edges(data=True)))
            if weight_attr in data:
                use_weight = weight_attr

        # --- Centralidades ---
        print("\nCalculando centralidades...")
        degree_dict = dict(Gi.degree())
        deg_centrality = nx.degree_centrality(Gi)

        if use_weight:
            closeness = nx.closeness_centrality(Gi, distance=use_weight)
            betweenness = nx.betweenness_centrality(Gi, weight=use_weight, normalized=True)
        else:
            closeness = nx.closeness_centrality(Gi)
            betweenness = nx.betweenness_centrality(Gi, normalized=True)

        # DataFrame de centralidades
        cent_df = pd.DataFrame({
            "node": list(Gi.nodes()),
            "nombre": [Gi.nodes[n].get("nombre", str(n)) for n in Gi.nodes()],
            "degree": [degree_dict[n] for n in Gi.nodes()],
            "deg_centrality": [deg_centrality[n] for n in Gi.nodes()],
            "closeness": [closeness[n] for n in Gi.nodes()],
            "betweenness": [betweenness[n] for n in Gi.nodes()],
        })

        # Puedes agregar m√°s atributos de nodos si los tienes
        # por ejemplo rating o tipo_motel:
        for attr in ["rating", "price_level", "tipo_motel", "zona_alto_impacto"]:
            if all(attr in Gi.nodes[n] for n in Gi.nodes()):
                cent_df[attr] = [Gi.nodes[n].get(attr) for n in Gi.nodes()]

        # --- Clustering ---
        if n_nodes > 1:
            clustering_avg = nx.average_clustering(Gi)
        else:
            clustering_avg = np.nan
        print(f"Clustering promedio: {clustering_avg:.4f}" if not np.isnan(clustering_avg)
              else "Clustering promedio: no aplica (muy pocos nodos).")

        # --- Caminos m√°s cortos (solo si hay >1 nodo) ---
        asp = np.nan
        diameter = np.nan
        if n_nodes > 1:
            try:
                asp = nx.average_shortest_path_length(Gi, weight=use_weight)
                print(f"Longitud promedio de camino (ASP): {asp:.4f}")
            except Exception as e:
                print("No fue posible calcular ASP:", e)

            try:
                # Di√°metro sin peso; puedes cambiarlo si quieres ponderado
                diameter = nx.diameter(Gi)
                print(f"Di√°metro (en saltos): {diameter}")
            except Exception as e:
                print("No fue posible calcular di√°metro:", e)
        else:
            print("Caminos m√°s cortos: no aplica (componente de un solo nodo).")

        # --- Comunidades y modularidad ---
        modularity_value = np.nan
        try:
            print("\nDetectando comunidades (greedy modularity)...")
            comms = list(community.greedy_modularity_communities(Gi, weight=use_weight))
            # Asignar ID de comunidad a cada nodo
            comm_map = {}
            for cid, com in enumerate(comms):
                for n in com:
                    comm_map[n] = cid
            nx.set_node_attributes(Gi, comm_map, "community_id")

            modularity_value = community.modularity(Gi, comms, weight=use_weight)
            print(f"N√∫mero de comunidades: {len(comms)}")
            print(f"Modularidad: {modularity_value:.4f}")
        except Exception as e:
            print("No fue posible calcular comunidades/modularidad:", e)

        # --- Top nodos por centralidad ---
        print("\nTop nodos por centralidad:")

        def show_top(df, col, titulo):
            top = df.sort_values(col, ascending=False).head(top_n)
            print(f"\n{titulo} (top {top_n}):")
            print(top[["nombre", col]].to_string(index=False))
            return top

        top_deg = show_top(cent_df, "deg_centrality", "Centralidad de grado")
        top_clo = show_top(cent_df, "closeness", "Centralidad de cercan√≠a")
        top_bet = show_top(cent_df, "betweenness", "Centralidad de betweenness")

        # --- Gr√°ficas b√°sicas ---

        # Histograma de grado
        plt.figure(figsize=(6,4))
        plt.hist(cent_df["degree"], bins=range(1, cent_df["degree"].max()+2))
        plt.xlabel("Grado")
        plt.ylabel("Frecuencia")
        plt.title(f"Distribuci√≥n de grado - {comp_name}")
        plt.tight_layout()
        plt.show()

        # Barras top betweenness
        plt.figure(figsize=(6,4))
        plt.bar(top_bet["nombre"], top_bet["betweenness"])
        plt.xticks(rotation=45, ha="right")
        plt.ylabel("Betweenness")
        plt.title(f"Top {top_n} nodos por betweenness - {comp_name}")
        plt.tight_layout()
        plt.show()

        # Layout simple de la red (spring layout) para la componente
        if n_nodes <= 200:  # por si alguna componente es muy grande
            pos = nx.spring_layout(Gi, weight=use_weight, seed=42)
            plt.figure(figsize=(6,6))
            nx.draw_networkx_nodes(Gi, pos, node_size=40, node_color="tomato")
            nx.draw_networkx_edges(Gi, pos, alpha=0.4)
            plt.title(f"Layout de la componente {idx} - {graph_name}")
            plt.axis("off")
            plt.tight_layout()
            plt.show()

        # Resumen de la componente para una tabla global
        resumen_componentes.append({
            "grafo": graph_name,
            "componente": idx,
            "n_nodos": n_nodes,
            "n_aristas": n_edges,
            "densidad": density,
            "grado_medio": avg_degree,
            "clustering_prom": clustering_avg,
            "ASP": asp,
            "diametro": diameter,
            "modularidad": modularity_value
        })

    resumen_df = pd.DataFrame(resumen_componentes)
    print("\n================ Resumen de componentes =================")
    print(resumen_df.to_string(index=False))

    return resumen_df

```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
# Tus grafos ya construidos con NetworkX
# G_moteles, G_burdeles, G_plus18

res_moteles = analyze_graph_components(G_motel_6, graph_name="Moteles", weight_attr="weight", top_n=5)

```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
res_burdeles = analyze_graph_components(G_burdel_6, graph_name="Burdeles", weight_attr="weight", top_n=5)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
res_plus18  = analyze_graph_components(G_completo_6,  graph_name="+18",      weight_attr="weight", top_n=5)
```






#CONJUNTO CHAT

```{python}
#| collapsed: true
import pandas as pd
import numpy as np
import networkx as nx
from sklearn.neighbors import NearestNeighbors
import folium

```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
# ---------- 1. CARGA DE DATOS ----------
#MOTELES
df_moteles = pd.read_csv("Moteles_Final.csv")
df_moteles["Tipo"] = "M"
df_moteles = df_moteles[df_moteles["rating"] != "NaN"]
df_moteles = df_moteles[df_moteles["rese√±as"] > 5]



df_burdel.to_csv("Burdel_Final.csv", index=False, encoding="utf-8")
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJh4haQhd5P44Rn7lSquE6f8o"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJPVDeUV-HP44Rrf0x1rQXjhA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJ9VrAAlqnMI4RUeDSfew1mKg"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJpSe6UOsvPo4Rwr_6YAFGPEU"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJmRV1Rl2mMI4RgFMlk1P2Ae4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJzebdbgauKIQRgmESxdUPwpM"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJO129iJApRI4R6-m82Lp8EL4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJv0qjX4WmMI4RQq8f_S8Vpc4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJree8KeanMI4R6Y7rEbkd_r0"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJm1P1nQouPo4R3ECNPcBsSDA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJcZ0NLCynMI4RZntyNjoIJA4"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJl-NMiyKmMI4RiXSpjMwZ4dA"]

df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJl3JggxSmMI4Re4SW-nOPFzA"]
df_burdel = df_burdel[df_burdel["id_lugar"] != "ChIJj4iM5cIFP44R_JKTzOW17lY"]

df_burdel["Tipo"] = "B"
df_burdel = df_burdel.drop_duplicates()
df_burdel = df_burdel[df_burdel["rating"] != "NaN"]
df_burdel = df_burdel[df_burdel["rese√±as"] > 5]



df_ambos = pd.read_csv("df_completo.csv")



# Limpieza b√°sica (ajusta a tus columnas reales)
def limpiar_df(df):
    df = df.dropna(subset=["lat", "lon"])
    df = df.drop_duplicates(subset=["id_lugar"])
    # rating num√©rico
    df["rating"] = pd.to_numeric(df["rating"], errors="coerce")
    df["rese√±as"] = pd.to_numeric(df["rese√±as"], errors="coerce")
    df["rese√±as"].fillna(0, inplace=True)
    # categor√≠as
    umbral_rating = 4.2
    mediana_res = df["rese√±as"].median()
    df["rating_alto"] = (df["rating"] >= umbral_rating).astype(int)
    df["rese√±as_altas"] = (df["rese√±as"] >= mediana_res).astype(int)
    return df

df_moteles = limpiar_df(df_moteles)
df_burdeles = limpiar_df(df_burdel)
df_ambos = limpiar_df(df_ambos)



df_moteles.shape
#, df_burdeles.shape, df_ambos.shape
df_moteles.head(3)
#, df_burdeles.head(3), df_ambos.head(3)

```

```{python}
#| colab: {base_uri: https://localhost:8080/}
# ---------- 2. CONSTRUCCI√ìN DEL GRAFO k-NN ----------
def construir_grafo_knn(df, k=2):
    """
    Construye grafo no dirigido por proximidad geogr√°fica (haversine, k-NN)
    """
    coords = np.radians(df[["lat", "lon"]].values)
    nbrs = NearestNeighbors(n_neighbors=k+1, metric="haversine")
    nbrs.fit(coords)
    dist, idx = nbrs.kneighbors(coords)

    G = nx.Graph()
    # A√±adir nodos con atributos
    for i, row in df.iterrows():
        G.add_node(
            row["id_lugar"],
            nombre=row.get("nombre"),
            lat=row["lat"],
            lon=row["lon"],
            rating=row.get("rating", np.nan),
            rese√±as=row.get("rese√±as", np.nan),
            rating_alto=row.get("rating_alto", 0),
            rese√±as_altas=row.get("rese√±as_altas", 0),
            tipo_est=row.get("tipo_est")  # motel / burdel / etc.
        )

    ids = df["id_lugar"].values
    # Crear aristas (omitimos el vecino 0, que es el mismo punto)
    for i, vecinos in enumerate(idx):
        for j_idx in vecinos[1:]:
            u = ids[i]
            v = ids[j_idx]
            if u != v:
                G.add_edge(u, v)

    return G

G_moteles = construir_grafo_knn(df_moteles, k=6)
G_burdeles = construir_grafo_knn(df_burdeles, k=6)
G_ambos = construir_grafo_knn(df_ambos, k=6)

print(G_moteles.number_of_nodes(), G_moteles.number_of_edges())
print(G_burdeles.number_of_nodes(), G_burdeles.number_of_edges())
print(G_ambos.number_of_nodes(), G_ambos.number_of_edges())

```

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
import matplotlib.pyplot as plt
import networkx as nx

def dibujar_grafo_knn(G, titulo="Grafo k-NN por proximidad geogr√°fica"):
    """
    Dibuja el grafo usando lat/lon de los nodos como posici√≥n.
    Colorea los nodos seg√∫n el tipo de establecimiento (si existe el atributo).
    """
    # Posiciones: x = lon, y = lat
    pos = {
        n: (datos["lon"], datos["lat"])
        for n, datos in G.nodes(data=True)
        if "lat" in datos and "lon" in datos
    }

    # Si no hay posiciones, salir
    if not pos:
        print("El grafo no tiene atributos 'lat' y 'lon' en los nodos.")
        return

    # Colorear por tipo_est (motel / burdel / etc.), si existe
    tipos = nx.get_node_attributes(G, "tipo_est")
    categorias = sorted(set(tipos.values())) if tipos else []

    # Asignar un color por categor√≠a (muy simple)
    palette = [
        "tab:blue", "tab:orange", "tab:green", "tab:red",
        "tab:purple", "tab:brown", "tab:pink", "tab:gray"
    ]
    color_map = {}
    if categorias:
        for i, cat in enumerate(categorias):
            color_map[cat] = palette[i % len(palette)]

        node_colors = [
            color_map.get(tipos.get(n), "tab:gray")
            for n in G.nodes()
        ]
    else:
        node_colors = "tab:blue"

    plt.figure(figsize=(8, 8))

    # Aristas
    nx.draw_networkx_edges(
        G,
        pos,
        alpha=0.3,
        width=0.8
    )

    # Nodos
    nx.draw_networkx_nodes(
        G,
        pos,
        node_size=40,
        node_color=node_colors,
        alpha=0.9
    )

    # (Opcional) Etiquetas muy peque√±as: mejor solo si el grafo no es enorme
    # labels = nx.get_node_attributes(G, "nombre")
    # nx.draw_networkx_labels(G, pos, labels, font_size=6)

    plt.title(titulo)
    plt.xlabel("Longitud")
    plt.ylabel("Latitud")
    plt.axis("equal")
    plt.tight_layout()
    plt.show()


dibujar_grafo_knn(G_moteles, "Grafo k-6")
dibujar_grafo_knn(G_burdeles, "Grafo k-6")
dibujar_grafo_knn(G_ambos, "Grafo k-6")

```

## Grado

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 352}
#| collapsed: true
#MOTEL
deg_dict_motel = dict(G_moteles.degree())

deg_df_motel = (pd.Series(deg_dict_motel, name="grado")
            .rename_axis("node_id")
            .reset_index())

#print(deg_df_motel)

# Contar cu√°ntos establecimientos tienen cada grado
conteo = deg_df_motel['grado'].value_counts().sort_index()

plt.figure(figsize=(8,5))
plt.bar(conteo.index, conteo.values, color='firebrick', edgecolor='black')

plt.xlabel("Grado")
plt.ylabel("N√∫mero de establecimientos")
plt.title("Distribuci√≥n del grado en la red de moteles")
plt.xticks(conteo.index)
plt.grid(axis='y', linestyle='--', alpha=0.4)

plt.show()
```

##m√©tricas

```{python}
#| colab: {base_uri: https://localhost:8080/}
#| collapsed: true
## ---------- 3. FUNCIONES DE AN√ÅLISIS ----------
from networkx.algorithms import community

def obtener_componente_gigante(G):
    componentes = list(nx.connected_components(G))
    if not componentes:
        return G.copy(), []
    giant_nodes = max(componentes, key=len)
    return G.subgraph(giant_nodes).copy(), componentes

def analizar_grafo(G, df, nombre_red=""):
    resumen = {}
    n = G.number_of_nodes()
    m = G.number_of_edges()
    resumen["n_nodos"] = n
    resumen["n_aristas"] = m
    resumen["densidad"] = nx.density(G)

    Gc, componentes = obtener_componente_gigante(G)
    resumen["n_componentes"] = len(componentes)
    resumen["tam_comp_gigante"] = Gc.number_of_nodes()

    if Gc.number_of_nodes() > 1:
        # Centralidades
        c_deg = nx.degree_centrality(Gc)
        c_clo = nx.closeness_centrality(Gc)
        c_bet = nx.betweenness_centrality(Gc, normalized=True)

        # Clustering
        clustering_nodes = nx.clustering(Gc)
        clustering_prom = nx.average_clustering(Gc)

        # Caminos m√°s cortos
        try:
            asp = nx.average_shortest_path_length(Gc)
            diam = nx.diameter(Gc)
        except nx.NetworkXError:
            asp, diam = np.nan, np.nan

        # Comunidades y modularidad
        comunidades = community.greedy_modularity_communities(Gc)
        # Lista de conjuntos -> calcular modularidad
        Q = community.modularity(Gc, comunidades)

        # Asortatividad por rating alto/bajo
        # Nos aseguramos de que el atributo est√° en el grafo
        for n_id in Gc.nodes():
            if "rating_alto" not in Gc.nodes[n_id]:
                # Mapear desde df
                row = df[df["id_lugar"] == n_id].iloc[0]
                Gc.nodes[n_id]["rating_alto"] = row["rating_alto"]
        r_rating = nx.attribute_assortativity_coefficient(Gc, "rating_alto")

        resumen.update({
            "asp": asp,
            "diametro": diam,
            "clustering_prom": clustering_prom,
            "modularidad_Q": Q,
            "n_comunidades": len(comunidades),
            "asortatividad_rating": r_rating
        })

        # Top 5 por centralidades
        cent_df = pd.DataFrame({
            "id_lugar": list(Gc.nodes()),
            "centralidad_grado": [c_deg[n] for n in Gc.nodes()],
            "centralidad_cercania": [c_clo[n] for n in Gc.nodes()],
            "centralidad_betweenness": [c_bet[n] for n in Gc.nodes()],
        }).merge(
            df[["id_lugar", "nombre", "rating", "rese√±as"]],
            on="id_lugar",
            how="left"
        )

        resumen["top5_grado"] = cent_df.sort_values(
            "centralidad_grado", ascending=False
        ).head(5)

        resumen["top5_cercania"] = cent_df.sort_values(
            "centralidad_cercania", ascending=False
        ).head(5)

        resumen["top5_betweenness"] = cent_df.sort_values(
            "centralidad_betweenness", ascending=False
        ).head(5)

        resumen["centralidades_df"] = cent_df

    else:
        resumen.update({
            "asp": np.nan,
            "diametro": np.nan,
            "clustering_prom": np.nan,
            "modularidad_Q": np.nan,
            "n_comunidades": 0,
            "asortatividad_rating": np.nan,
        })

    return resumen, Gc

res_moteles, Gc_moteles = analizar_grafo(G_moteles, df_moteles, "Moteles")
Gc_moteles = obtener_componente_gigante(G_moteles)[0]
res_burdeles, Gc_burdeles = analizar_grafo(G_burdeles, df_burdeles, "Burdeles")
res_ambos, Gc_ambos = analizar_grafo(G_ambos, df_ambos, "Integrada")

#print(res_moteles['clustering_prom'])
#print(nx.clustering(Gc_moteles))
#print(nx.triangles(Gc_moteles))

print(res_moteles['asp'], res_moteles['diametro'])
```

## Cluster

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 356}
import matplotlib.pyplot as plt

clust = nx.clustering(Gc_moteles)

plt.figure(figsize=(8,5))
plt.hist(list(clust.values()), bins=10, edgecolor='black')
plt.xlabel('Coeficiente de clustering')
plt.ylabel('Frecuencia')
plt.title('Distribuci√≥n del coeficiente de clustering por nodo')
plt.grid(alpha=0.3)
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 719}
#| collapsed: true
import folium
import numpy as np

clust = nx.clustering(Gc_moteles)

# Centro del mapa:
lats = [Gc_moteles.nodes[n]["lat"] for n in Gc_moteles.nodes()]
lons = [Gc_moteles.nodes[n]["lon"] for n in Gc_moteles.nodes()]
m = folium.Map(location=[np.mean(lats), np.mean(lons)], zoom_start=12)

for n in Gc_moteles.nodes():
    c = clust[n]

    # Asignar color seg√∫n rangos de clustering
    if c > 0.9:
        color = "green"      # Clustering alto
    elif 0.6 <= c <= 0.9:
        color = "yellow"     # Clustering medio
    else:
        color = "red"        # Clustering bajo

    folium.CircleMarker(
        location=[Gc_moteles.nodes[n]["lat"], Gc_moteles.nodes[n]["lon"]],
        radius=5,
        color=color,
        fill=True,
        fill_color=color,
        fill_opacity=0.7,
        popup=f"{Gc_moteles.nodes[n]['nombre']}<br>Clustering={c:.2f}"
    ).add_to(m)

m.save("mapa_clustering_moteles.html")
m
```

```{python}
#| collapsed: true
#| colab: {base_uri: https://localhost:8080/, height: 238}
import pandas as pd

clust_df = pd.DataFrame({
    "motel": list(clust.keys()),
    "clustering": list(clust.values())
})

top_clust = clust_df.sort_values("clustering", ascending=False).head(10)

plt.figure(figsize=(10,5))
plt.barh(top_clust["motel"], top_clust["clustering"])
plt.gca().invert_yaxis()
plt.xlabel("Clustering")
plt.title("Top 10 moteles con mayor clustering")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 523}
#| collapsed: true
tri = nx.triangles(Gc_moteles)
nodos_con_tri = [n for n,t in tri.items() if t > 0]
subG = Gc_moteles.subgraph(nodos_con_tri).copy()
plt.figure(figsize=(6,6))
pos = nx.spring_layout(subG, seed=42)
nx.draw(subG, pos, with_labels=False, node_size=80, node_color='skyblue', edge_color='gray')
plt.title("Subgrafo de moteles que forman tri√°ngulos")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
#| collapsed: true
import networkx as nx
import matplotlib.pyplot as plt

# -------------------------
# 1. Layout de resorte (spring) para TODO el grafo
# -------------------------
pos = nx.spring_layout(Gc_moteles, seed=42)  # layout fijo y reproducible

# Colores por grado para el grafo completo
degrees = dict(Gc_moteles.degree())
node_colors = [degrees[n] for n in Gc_moteles.nodes()]

plt.figure(figsize=(7, 7))
nx.draw(
    Gc_moteles,
    pos,
    node_color=node_colors,
    node_size=80,
    edge_color="gray",
    cmap=plt.cm.viridis,
    with_labels=False
)
cbar = plt.colorbar(plt.cm.ScalarMappable(cmap=plt.cm.viridis),
                    ax=plt.gca(),
                    shrink=0.8)
cbar.set_label("Grado del nodo")
plt.title("Grafo de moteles coloreado por grado (layout de resorte)")
plt.axis("off")
plt.show()

# -------------------------
# 2. Subgrafo de moteles que forman tri√°ngulos,
#    usando las MISMAS posiciones 'pos'
# -------------------------
# Tri√°ngulos por nodo
triangles = nx.triangles(Gc_moteles)
nodos_con_tri = [n for n, t in triangles.items() if t > 0]

subG = Gc_moteles.subgraph(nodos_con_tri).copy()

plt.figure(figsize=(7, 7))
nx.draw(
    subG,
    {n: pos[n] for n in subG.nodes()},  # mismas coords del layout global
    node_color="skyblue",
    node_size=80,
    edge_color="gray",
    with_labels=False
)
plt.title("Subgrafo de moteles que forman tri√°ngulos\n(mismas posiciones que el grafo completo)")
plt.axis("off")
plt.show()

# -------------------------
# 3. Grafo usando POSICI√ìN GEOGR√ÅFICA (lon, lat)
# -------------------------
pos_geo = {n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
           for n in Gc_moteles.nodes()}

plt.figure(figsize=(7, 7))
nx.draw(
    Gc_moteles,
    pos_geo,
    node_color=node_colors,
    node_size=80,
    edge_color="gray",
    cmap=plt.cm.viridis,
    with_labels=False
)
cbar = plt.colorbar(plt.cm.ScalarMappable(cmap=plt.cm.viridis),
                    ax=plt.gca(),
                    shrink=0.8)
cbar.set_label("Grado del nodo")
plt.title("Grafo de moteles con posici√≥n geogr√°fica (lon, lat)")
plt.axis("equal")   # para que no se deforme la geometr√≠a
plt.axis("off")
plt.show()

```

##Tri√°ngulos

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
import networkx as nx
import matplotlib.pyplot as plt

# -------------------------
# 1. POSICI√ìN GEOGR√ÅFICA PARA TODO EL GRAFO
# -------------------------
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

# Guardamos los l√≠mites para reutilizarlos en el subgrafo
xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# Colores por grado (opcional)
degrees = dict(Gc_moteles.degree())
node_colors = [degrees[n] for n in Gc_moteles.nodes()]

plt.figure(figsize=(7, 7))
nx.draw(
    Gc_moteles,
    pos_geo,
    node_color=node_colors,
    node_size=60,
    edge_color="gray",
    cmap=plt.cm.viridis,
    with_labels=False
)
plt.title("Grafo de moteles con posici√≥n geogr√°fica (lon, lat)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()

# -------------------------
# 2. SUBGRAFO DE MOTELes QUE FORMAN TRI√ÅNGULOS
#    (MISMA GEOMETR√çA QUE EL GRAFO COMPLETO)
# -------------------------

# Nodos que participan en al menos un tri√°ngulo
triangles = nx.triangles(Gc_moteles)
nodos_con_tri = [n for n, t in triangles.items() if t > 0]

subG = Gc_moteles.subgraph(nodos_con_tri).copy()

# Posiciones geogr√°ficas del subgrafo (tomadas del diccionario global)
pos_geo_sub = {n: pos_geo[n] for n in subG.nodes()}

plt.figure(figsize=(7, 7))
nx.draw(
    subG,
    pos_geo_sub,
    node_color="skyblue",
    node_size=70,
    edge_color="gray",
    with_labels=False
)
plt.title("Subgrafo de moteles que forman tri√°ngulos\n(posici√≥n geogr√°fica)")
plt.axis("equal")
plt.xlim(x_min, x_max)   # mismos l√≠mites que el grafo completo
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 392}
#| collapsed: true
deg = dict(Gc_moteles.degree())

plt.figure(figsize=(7,5))
plt.scatter(list(deg.values()), list(clust.values()))
plt.xlabel("Grado")
plt.ylabel("Clustering")
plt.title("Relaci√≥n entre grado y clustering en la red de moteles")
plt.grid(alpha=0.3)
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 545}
#| collapsed: true
plt.figure(figsize=(4,6))
plt.boxplot(list(clust.values()))
plt.ylabel("Coeficiente de clustering")
plt.title("Distribuci√≥n de clustering en moteles")
plt.grid(alpha=0.3)
plt.show()
```

## caminos cortos y di√°metro

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 625}
#| collapsed: true
import networkx as nx
import matplotlib.pyplot as plt

# -------------------------
# 1. Posici√≥n geogr√°fica de todos los moteles
# -------------------------
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

# Guardamos l√≠mites para que el subgrafo use la misma "caja"
xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# -------------------------
# 2. Encontrar el par de nodos que define el di√°metro
# -------------------------
# (Puedes usar nx.diameter(Gc_moteles) si ya lo calculaste)

all_lengths = dict(nx.all_pairs_shortest_path_length(Gc_moteles))

max_dist = -1
nodo_u, nodo_v = None, None

for u, dist_dict in all_lengths.items():
    for v, d in dist_dict.items():
        if d > max_dist:
            max_dist = d
            nodo_u, nodo_v = u, v

print(f"Di√°metro = {max_dist}, entre los nodos {nodo_u} y {nodo_v}")

# Caminos m√°s cortos entre ese par (camino geod√©sico)
diameter_path = nx.shortest_path(Gc_moteles, source=nodo_u, target=nodo_v)

print("Camino del di√°metro:")
print(diameter_path)

# Conjunto de nodos y aristas del camino
nodos_diametro = set(diameter_path)
aristas_diametro = list(zip(diameter_path[:-1], diameter_path[1:]))

# -------------------------
# 3. Dibujar la red + resaltar el camino del di√°metro
# -------------------------
plt.figure(figsize=(8, 8))

# 3.1. Toda la red en gris
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edge_color="lightgray",
    width=1
)

nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    node_size=40,
    node_color="lightgray"
)

# 3.2. Camino del di√°metro en rojo
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edgelist=aristas_diametro,
    edge_color="red",
    width=2.5
)

nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=nodos_diametro,
    node_color="red",
    node_size=80
)

# 3.3. Resaltar extremos del di√°metro (inicio y fin)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=[nodo_u, nodo_v],
    node_color="darkred",
    node_size=120
)

# (Opcional) etiquetas para los extremos
labels_extremos = {
    nodo_u: Gc_moteles.nodes[nodo_u].get("nombre", str(nodo_u)),
    nodo_v: Gc_moteles.nodes[nodo_v].get("nombre", str(nodo_v))
}
nx.draw_networkx_labels(
    Gc_moteles,
    pos_geo,
    labels=labels_extremos,
    font_size=8,
    font_color="black"
)

plt.title("Camino geod√©sico que define el di√°metro\n(red de moteles, coordenadas geogr√°ficas)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()
```

##Comunidades

```{python}
#| colab: {base_uri: https://localhost:8080/}
print(community.greedy_modularity_communities(Gc_moteles))
print(res_moteles['modularidad_Q'])
print(res_moteles['n_comunidades'])
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 659}
#| collapsed: true
import networkx as nx
import matplotlib.pyplot as plt
from networkx.algorithms import community

# -----------------------------------
# 1. Calcular comunidades (si no lo has hecho)
# -----------------------------------
comunidades = community.greedy_modularity_communities(Gc_moteles)

print(f"N√∫mero de comunidades: {len(comunidades)}")

# -----------------------------------
# 2. Crear un diccionario: nodo -> √≠ndice de comunidad
# -----------------------------------
comunidad_por_nodo = {}
for idx, com in enumerate(comunidades):
    for n in com:
        comunidad_por_nodo[n] = idx

# -----------------------------------
# 3. Layout de resorte (fijo para reproducibilidad)
# -----------------------------------
pos = nx.spring_layout(Gc_moteles, seed=42)

# -----------------------------------
# 4. Preparar colores por comunidad
# -----------------------------------
# Usamos una paleta categ√≥rica (tab10 tiene hasta 10 colores distintos)
cmap = plt.cm.get_cmap("tab10", len(comunidades))

node_colors = [cmap(comunidad_por_nodo[n]) for n in Gc_moteles.nodes()]

# -----------------------------------
# 5. Dibujar el grafo coloreado por comunidades
# -----------------------------------
plt.figure(figsize=(8, 8))

nx.draw_networkx_edges(
    Gc_moteles,
    pos,
    edge_color="lightgray",
    width=0.8,
    alpha=0.8
)

nx.draw_networkx_nodes(
    Gc_moteles,
    pos,
    node_color=node_colors,
    node_size=70,
    linewidths=0.3,
    edgecolors="black"
)

plt.title("Red de moteles coloreada por comunidades\n(layout de resorte)")
plt.axis("off")
plt.show()

# -----------------------------------
# 6. (Opcional) Tabla r√°pida de tama√±os de comunidad
# -----------------------------------
for idx, com in enumerate(comunidades):
    print(f"Comunidad {idx}: {len(com)} nodos")
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 676}
import networkx as nx
import matplotlib.pyplot as plt
from networkx.algorithms import community

# -----------------------------------
# 1. Calcular comunidades (si no lo has hecho)
# -----------------------------------
comunidades = community.greedy_modularity_communities(Gc_moteles)

print(f"N√∫mero de comunidades: {len(comunidades)}")

# -----------------------------------
# 2. Diccionario nodo -> √≠ndice de comunidad
# -----------------------------------
comunidad_por_nodo = {}
for idx, com in enumerate(comunidades):
    for n in com:
        comunidad_por_nodo[n] = idx

# -----------------------------------
# 3. Posici√≥n geogr√°fica: lon, lat
# -----------------------------------
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

# Guardamos l√≠mites para que no se deforme al dibujar
xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# -----------------------------------
# 4. Colores por comunidad
# -----------------------------------
cmap = plt.cm.get_cmap("tab10", len(comunidades))
node_colors = [cmap(comunidad_por_nodo[n]) for n in Gc_moteles.nodes()]

# -----------------------------------
# 5. Dibujar grafo geogr√°fico coloreado por comunidades
# -----------------------------------
plt.figure(figsize=(8, 8))

# Aristas en gris claro
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edge_color="lightgray",
    width=0.8,
    alpha=0.8
)

# Nodos coloreados por comunidad
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    node_color=node_colors,
    node_size=70,
    linewidths=0.3,
    edgecolors="black"
)

plt.title("Red de moteles coloreada por comunidades\n(coordenadas geogr√°ficas)")
plt.axis("equal")   # respeta la proporci√≥n lon/lat
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()

# -----------------------------------
# 6. (Opcional) Resumen de tama√±os de comunidad
# -----------------------------------
for idx, com in enumerate(comunidades):
    print(f"Comunidad {idx}: {len(com)} nodos")
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 163}
import networkx as nx
import pandas as pd
import numpy as np
from networkx.algorithms import community

# -----------------------------------
# 1. Calcular comunidades (si no lo has hecho antes)
# -----------------------------------
comunidades = community.greedy_modularity_communities(Gc_moteles)


# -----------------------------------
# 2. M√©tricas de cada comunidad
# -----------------------------------
total_nodos = Gc_moteles.number_of_nodes()
filas = []

for idx, com in enumerate(comunidades):
    subG = Gc_moteles.subgraph(com).copy()

    n = subG.number_of_nodes()
    m = subG.number_of_edges()
    densidad = nx.density(subG)

    # Grado promedio dentro de la comunidad
    grados = dict(subG.degree())
    grado_prom = np.mean(list(grados.values())) if grados else np.nan

    # Clustering promedio dentro de la comunidad
    try:
        clustering_prom = nx.average_clustering(subG)
    except ZeroDivisionError:
        clustering_prom = np.nan

    # ASP (si la comunidad es conexa y tiene m√°s de 1 nodo)
    if n > 1 and nx.is_connected(subG):
        try:
            asp = nx.average_shortest_path_length(subG)
        except nx.NetworkXError:
            asp = np.nan
    else:
        asp = np.nan

    # Rating promedio (si existe el atributo)
    ratings = []
    for nodo in subG.nodes():
        r = subG.nodes[nodo].get("rating", np.nan)
        if r is not None:
            ratings.append(r)
    rating_prom = np.nanmean(ratings) if len(ratings) > 0 else np.nan

    filas.append({
        "comunidad": idx,
        "n_nodos": n,
        "n_aristas": m,
        "densidad_interna": densidad,
        "grado_promedio": grado_prom,
        "clustering_promedio": clustering_prom,
        "ASP_comunidad": asp
    })

df_comunidades = pd.DataFrame(filas)
df_comunidades
```

## Asor no s√© que por raiting

```{python}
#| colab: {base_uri: https://localhost:8080/}
res_moteles['asortatividad_rating']
```

## Top 5

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 310}
#| collapsed: true
import pandas as pd

# Selecci√≥n de columnas y creaci√≥n de ranking
res_moteles_5grado = res_moteles["top5_betweenness"].copy()

# Crear columna del 1 al 5
res_moteles_5grado["rank"] = range(1, len(res_moteles_5grado) + 1)

# Reordenar columnas como las quieres
res_moteles_5grado = res_moteles_5grado[[
    "rank",
    "nombre",
    "centralidad_betweenness",
    "rating",
    "rese√±as"
]]


res_moteles_5grado.style\
    .hide(axis="index")\
    .set_caption("Top 5 por Centralidad de Betweenness")\
    .apply(lambda x: ['background-color: #E9967A' if i%2==0 else 'background-color: white'
                      for i in range(len(x))], axis=0)

```

```{python}
#| colab: {base_uri: https://localhost:8080/}
# ---------- 4. AN√ÅLISIS DE SENSIBILIDAD ----------
def analisis_sensibilidad(Gc, res_dict, n_top=3):
    """
    Gc: componente gigante
    res_dict: diccionario con m√©tricas antes (asp, n_componentes, etc.)
    """
    # Extract the scalar value from the 'asp' Series
    base_asp = res_dict["asp"].iloc[0] if not res_dict["asp"].empty else np.nan
    base_comp = res_dict["n_componentes"].iloc[0] if not res_dict["n_componentes"].empty else 1  # assuming default 1 if empty

    # Tomar top por betweenness
    c_bet = nx.betweenness_centrality(Gc, normalized=True)
    top_nodes = sorted(c_bet, key=c_bet.get, reverse=True)[:n_top]

    filas = []
    for nodo in top_nodes:
        G_tmp = Gc.copy()
        G_tmp.remove_node(nodo)

        componentes_despues = list(nx.connected_components(G_tmp))
        n_comp_despues = len(componentes_despues)
        try:
            # Ensure to work with the largest component after removal
            if componentes_despues:
                largest_comp_nodes = max(componentes_despues, key=len)
                asp_despues = nx.average_shortest_path_length(
                    G_tmp.subgraph(largest_comp_nodes)
                )
            else:
                asp_despues = np.nan # No components left
        except nx.NetworkXError:
            asp_despues = np.nan

        filas.append({
            "lugar_removido": Gc.nodes[nodo].get("nombre", nodo), # Get node name for clarity
            "componentes_antes": base_comp,
            "componentes_despues": n_comp_despues,
            "asp_antes": base_asp,
            "asp_despues": asp_despues,
            "delta_componentes": n_comp_despues - base_comp,
            "delta_asp": asp_despues - base_asp if pd.notna(base_asp) and pd.notna(asp_despues) else np.nan
        })

    return pd.DataFrame(filas)

sens_moteles = analisis_sensibilidad(Gc_moteles, res_moteles)
sens_burdeles = analisis_sensibilidad(Gc_burdeles, res_burdeles)
sens_ambos = analisis_sensibilidad(Gc_ambos, res_ambos)

print("Sensibilidad para moteles:")
print(sens_moteles)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 525}
import folium
import numpy as np
from IPython.display import display

# ---------- 5. MAPA FOLIUM B√ÅSICO ----------
def mapa_folium_comunidades(Gc, comunidades, nombre_html="mapa_red.html",
                            mostrar=True, guardar=True):
    """
    Crea un mapa de Folium con los nodos coloreados por comunidad.
    - guardar=True  => guarda el .html
    - mostrar=True  => muestra el mapa interactivo de inmediato (Jupyter/Colab)
    """
    # Crear mapa centrado en el promedio de coordenadas
    lats = [Gc.nodes[n]["lat"] for n in Gc.nodes()]
    lons = [Gc.nodes[n]["lon"] for n in Gc.nodes()]
    center_lat, center_lon = np.mean(lats), np.mean(lons)

    m = folium.Map(location=[center_lat, center_lon], zoom_start=12)

    # Asignar comunidad a cada nodo
    etiqueta_comunidad = {}
    for idx, com in enumerate(comunidades):
        for n in com:
            etiqueta_comunidad[n] = idx

    # Paleta simple de colores
    colores = [
        "red", "blue", "green", "purple", "orange",
        "darkred", "lightred", "beige", "darkblue", "darkgreen",
        "cadetblue", "darkpurple", "white", "pink", "lightblue",
        "lightgreen", "gray", "black", "lightgray"
    ]

    for n in Gc.nodes():
        c = etiqueta_comunidad.get(n, 0)
        color = colores[c % len(colores)]
        folium.CircleMarker(
            location=[Gc.nodes[n]["lat"], Gc.nodes[n]["lon"]],
            radius=4,
            popup=f"{Gc.nodes[n].get('nombre','')} (rating={Gc.nodes[n].get('rating')})",
            tooltip=f"Comunidad {c}",
            color=color,
            fill=True,
            fill_color=color,
            fill_opacity=0.7
        ).add_to(m)

    if guardar:
        m.save(nombre_html)
    if mostrar:
        display(m)

    return m

comunidades_moteles = community.greedy_modularity_communities(Gc_moteles)
mapa_moteles = mapa_folium_comunidades(
    Gc_moteles,
    comunidades_moteles,
    nombre_html="mapa_moteles.html",
    mostrar=True,   # muestra el mapa
    guardar=False    # guarda el html
)
```

## m√°s graficas

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
import networkx as nx
import matplotlib.pyplot as plt

# =====================================================
# POSICIONES GEOGR√ÅFICAS (LAS USAMOS EN TODOS LOS GRAFOS)
# =====================================================
pos_geo_full = {n: (G_moteles.nodes[n]["lon"], G_moteles.nodes[n]["lat"])
                for n in G_moteles.nodes()}
xs = [p[0] for p in pos_geo_full.values()]
ys = [p[1] for p in pos_geo_full.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

pos_geo_gig = {n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
               for n in Gc_moteles.nodes()}

# =====================================================
# 1) TRI√ÅNGULOS: SUBGRAFO DE NODOS QUE FORMAN TRI√ÅNGULOS
# =====================================================
triangles = nx.triangles(Gc_moteles)
nodos_con_tri = [n for n, t in triangles.items() if t > 0]

sub_tri = Gc_moteles.subgraph(nodos_con_tri).copy()
pos_geo_tri = {n: pos_geo_gig[n] for n in sub_tri.nodes()}

plt.figure(figsize=(7, 7))
nx.draw_networkx_edges(
    sub_tri,
    pos_geo_tri,
    edge_color="gray",
    width=1
)
nx.draw_networkx_nodes(
    sub_tri,
    pos_geo_tri,
    node_color="skyblue",
    node_size=70,
    edgecolors="black",
    linewidths=0.3
)
plt.title("Subgrafo de moteles que forman tri√°ngulos\n(posici√≥n geogr√°fica)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()

# =====================================================
# 2) PUENTES: ARISTAS QUE SON CR√çTICAS PARA LA CONECTIVIDAD
#    (BRIDGES) + NODOS INCIDENTES
# =====================================================
# Usamos solo la componente gigante para evitar problemas
bridges = list(nx.bridges(Gc_moteles))
nodos_puente = set([u for u, v in bridges] + [v for u, v in bridges])

plt.figure(figsize=(7, 7))

# Toda la red en gris claro
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo_gig,
    edge_color="lightgray",
    width=0.8,
    alpha=0.8
)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo_gig,
    node_color="lightgray",
    node_size=50
)

# Puentes en rojo
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo_gig,
    edgelist=bridges,
    edge_color="red",
    width=2
)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo_gig,
    nodelist=nodos_puente,
    node_color="red",
    node_size=90
)

plt.title("Puentes en la componente gigante de la red de moteles\n(aristas cuya eliminaci√≥n fragmenta la red)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()

# =====================================================
# 3) SUBREDES AISLADAS: COMPONENTES CONEXAS PEQUE√ëAS
#    (FUERA DE LA COMPONENTE GIGANTE)
# =====================================================
componentes = list(nx.connected_components(G_moteles))
# Identificamos la componente gigante por tama√±o
comp_gig = max(componentes, key=len)
componentes_peq = [c for c in componentes if c != comp_gig]

nodos_aislados = set().union(*componentes_peq) if componentes_peq else set()
sub_aisladas = G_moteles.subgraph(nodos_aislados).copy()
pos_geo_aisladas = {n: pos_geo_full[n] for n in sub_aisladas.nodes()}

plt.figure(figsize=(7, 7))

# Toda la red en gris muy tenue
nx.draw_networkx_edges(
    G_moteles,
    pos_geo_full,
    edge_color="lightgray",
    width=0.5,
    alpha=0.3
)
nx.draw_networkx_nodes(
    G_moteles,
    pos_geo_full,
    node_color="lightgray",
    node_size=30,
    alpha=0.3
)

# Subredes aisladas resaltadas en azul
nx.draw_networkx_edges(
    sub_aisladas,
    pos_geo_aisladas,
    edge_color="blue",
    width=1.5
)
nx.draw_networkx_nodes(
    sub_aisladas,
    pos_geo_aisladas,
    node_color="dodgerblue",
    node_size=80,
    edgecolors="black",
    linewidths=0.4
)

plt.title("Subredes aisladas en la red de moteles\n(componentes distintas a la gigante)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 572}
import networkx as nx
import matplotlib.pyplot as plt

# -----------------------------------
# 1. Definir umbral de rating "alto"
# -----------------------------------
umbral_rating_alto = 4.2   # ajusta si tu criterio es distinto

# Crear atributo binario rating_alto en el grafo (True/False)
for n in Gc_moteles.nodes():
    r = Gc_moteles.nodes[n].get("rating", None)
    if r is not None:
        Gc_moteles.nodes[n]["rating_alto"] = (r >= umbral_rating_alto)
    else:
        # Si no hay rating, lo tratamos como "no alto"
        Gc_moteles.nodes[n]["rating_alto"] = False

# -----------------------------------
# 2. Posici√≥n geogr√°fica (lon, lat)
# -----------------------------------
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# -----------------------------------
# 3. Listas de nodos por tipo de rating
# -----------------------------------
nodos_rating_alto = [n for n in Gc_moteles.nodes()
                     if Gc_moteles.nodes[n]["rating_alto"]]
nodos_rating_bajo = [n for n in Gc_moteles.nodes()
                     if not Gc_moteles.nodes[n]["rating_alto"]]

# -----------------------------------
# 4. Dibujar grafo geogr√°fico coloreado por rating
# -----------------------------------
plt.figure(figsize=(8, 8))

# Aristas en gris claro
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edge_color="lightgray",
    width=0.8,
    alpha=0.8
)

# Nodos con rating bajo (rojo)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=nodos_rating_bajo,
    node_color="red",
    node_size=70,
    edgecolors="black",
    linewidths=0.3,
    label=f"Rating < {umbral_rating_alto}"
)

# Nodos con rating alto (verde)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=nodos_rating_alto,
    node_color="green",
    node_size=80,
    edgecolors="black",
    linewidths=0.3,
    label=f"Rating ‚â• {umbral_rating_alto}"
)

plt.title("Red de moteles coloreada por rating alto/bajo\n(coordenadas geogr√°ficas)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.legend(loc="lower left")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 677}
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# Posici√≥n geogr√°fica
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}
xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# -----------------------------
# 1. Betweenness de los nodos
# -----------------------------
btw = nx.betweenness_centrality(Gc_moteles, normalized=True)

# Tomamos, por ejemplo, los 5 nodos con mayor betweenness
k = 5
top_nodes = sorted(btw, key=btw.get, reverse=True)[:k]

print("Top nodos por betweenness:")
for n in top_nodes:
    print(n, btw[n])

# Aristas incidentes a esos nodos (para resaltarlas tambi√©n)
top_edges = []
for u, v in Gc_moteles.edges():
    if u in top_nodes or v in top_nodes:
        top_edges.append((u, v))

# -----------------------------
# 2. Dibujo: red completa + ‚Äúpuentes‚Äù por betweenness
# -----------------------------
plt.figure(figsize=(8, 8))

# Toda la red en gris claro
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edge_color="lightgray",
    width=0.8,
    alpha=0.7
)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    node_color="lightgray",
    node_size=50,
    alpha=0.7
)

# Aristas incidentes a los nodos puente en rojo
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edgelist=top_edges,
    edge_color="orange",
    width=1.0,
    alpha=0.9
)

# Nodos puente en rojo m√°s grande
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=top_nodes,
    node_color="red",
    node_size=120,
    edgecolors="black",
    linewidths=0.6,
    alpha=0.95
)

plt.title("Nodos puente seg√∫n betweenness\n(red de moteles, coordenadas geogr√°ficas)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 572}
import networkx as nx
import matplotlib.pyplot as plt

# -----------------------------------
# 1. Umbrales de rating
# -----------------------------------
umbral_verde = 4.2
umbral_amarillo = 3.8

# -----------------------------------
# 2. Posici√≥n geogr√°fica (lon, lat)
# -----------------------------------
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# -----------------------------------
# 3. Clasificar nodos seg√∫n rating
# -----------------------------------
nodos_verdes = []
nodos_amarillos = []
nodos_rojos = []

for n in Gc_moteles.nodes():
    r = Gc_moteles.nodes[n].get("rating", None)

    if r is None:
        # Sin rating ‚Üí lo mandamos a rojo
        nodos_rojos.append(n)
    else:
        if r > umbral_verde:
            nodos_verdes.append(n)
        elif r > umbral_amarillo:
            nodos_amarillos.append(n)
        else:
            nodos_rojos.append(n)

# -----------------------------------
# 4. Dibujar grafo geogr√°fico coloreado por rating
# -----------------------------------
plt.figure(figsize=(8, 8))

# Aristas en gris claro
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edge_color="lightgray",
    width=0.8,
    alpha=0.8
)

# Nodos rojos (rating <= 3.8 o sin rating)
if nodos_rojos:
    nx.draw_networkx_nodes(
        Gc_moteles,
        pos_geo,
        nodelist=nodos_rojos,
        node_color="red",
        node_size=70,
        edgecolors="black",
        linewidths=0.3,
        label=f"Rating ‚â§ {umbral_amarillo} o sin dato"
    )

# Nodos amarillos (3.8 < rating ‚â§ 4.2)
if nodos_amarillos:
    nx.draw_networkx_nodes(
        Gc_moteles,
        pos_geo,
        nodelist=nodos_amarillos,
        node_color="yellow",
        node_size=80,
        edgecolors="black",
        linewidths=0.3,
        label=f"{umbral_amarillo} < Rating ‚â§ {umbral_verde}"
    )

# Nodos verdes (rating > 4.2)
if nodos_verdes:
    nx.draw_networkx_nodes(
        Gc_moteles,
        pos_geo,
        nodelist=nodos_verdes,
        node_color="green",
        node_size=90,
        edgecolors="black",
        linewidths=0.3,
        label=f"Rating > {umbral_verde}"
    )

plt.title("Red de moteles coloreada por rating\n(coordenadas geogr√°ficas)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.legend(loc="lower left")
plt.show()
```

```{python}
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# -----------------------------
# Posici√≥n geogr√°fica
# -----------------------------
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)


def dibujar_centralidad_geografica(G, centralidades, titulo):
    """
    G: grafo (Gc_moteles)
    centralidades: dict {nodo: valor_centralidad}
    titulo: str, t√≠tulo del gr√°fico
    """

    vals = np.array(list(centralidades.values()))

    # Umbrales por cuantiles
    q_verde = np.quantile(vals, 0.80)   # top 20%
    q_amarillo = np.quantile(vals, 0.40)  # 40%

    nodos_verdes = []
    nodos_amarillos = []
    nodos_rojos = []

    for n, c in centralidades.items():
        if c >= q_verde:
            nodos_verdes.append(n)
        elif c >= q_amarillo:
            nodos_amarillos.append(n)
        else:
            nodos_rojos.append(n)

    plt.figure(figsize=(8, 8))

    # Aristas en gris claro
    nx.draw_networkx_edges(
        G,
        pos_geo,
        edge_color="lightgray",
        width=0.8,
        alpha=0.8
    )

    # Nodos rojos (centralidad baja)
    if nodos_rojos:
        nx.draw_networkx_nodes(
            G,
            pos_geo,
            nodelist=nodos_rojos,
            node_color="red",
            node_size=60,
            edgecolors="black",
            linewidths=0.3,
            label="Centralidad baja"
        )

    # Nodos amarillos (centralidad media)
    if nodos_amarillos:
        nx.draw_networkx_nodes(
            G,
            pos_geo,
            nodelist=nodos_amarillos,
            node_color="yellow",
            node_size=70,
            edgecolors="black",
            linewidths=0.3,
            label="Centralidad media"
        )

    # Nodos verdes (centralidad alta)
    if nodos_verdes:
        nx.draw_networkx_nodes(
            G,
            pos_geo,
            nodelist=nodos_verdes,
            node_color="green",
            node_size=80,
            edgecolors="black",
            linewidths=0.3,
            label="Centralidad alta"
        )

    plt.title(titulo)
    plt.axis("equal")
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    plt.axis("off")
    plt.legend(loc="lower left")
    plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 572}
# Centralidad de grado (normalizada por NetworkX)
c_deg = nx.degree_centrality(Gc_moteles)

dibujar_centralidad_geografica(
    Gc_moteles,
    c_deg,
    "Red de moteles coloreada por centralidad de grado\n(coordenadas geogr√°ficas)"
)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 573}
# Centralidad de cercan√≠a (closeness)
c_closeness = nx.closeness_centrality(Gc_moteles)

dibujar_centralidad_geografica(
    Gc_moteles,
    c_closeness,
    "Red de moteles coloreada por centralidad de cercan√≠a\n(coordenadas geogr√°ficas)"
)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 1000}
import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# -------------------------------------------------
# 1. Filtrar moteles con m√°s de 50 rese√±as
# -------------------------------------------------
umbral_rese√±as = 50

nodos_mas50 = [
    n for n in Gc_moteles.nodes()
    if Gc_moteles.nodes[n].get("rese√±as", 0) > umbral_rese√±as
]

print(f"N√∫mero de moteles con m√°s de {umbral_rese√±as} rese√±as:", len(nodos_mas50))

# Si no hay suficientes, revisa que el atributo se llame exactamente 'user_ratings_total'

# -------------------------------------------------
# 2. Subgrafo inducido por nodos con > 50 rese√±as
# -------------------------------------------------
G_50 = Gc_moteles.subgraph(nodos_mas50).copy()

print("Nodos en el subgrafo:", G_50.number_of_nodes())
print("Aristas en el subgrafo:", G_50.number_of_edges())

# -------------------------------------------------
# 3. M√©tricas importantes del subgrafo
# -------------------------------------------------

# Componentes conexos
componentes_50 = list(nx.connected_components(G_50))
n_componentes_50 = len(componentes_50)
print("N√∫mero de componentes conexos en el subgrafo:", n_componentes_50)

# Componente gigante del subgrafo (por si quieres medir ASP y di√°metro)
if n_componentes_50 > 0:
    comp_gig_50 = max(componentes_50, key=len)
    Gc_50 = G_50.subgraph(comp_gig_50).copy()
else:
    Gc_50 = G_50  # vac√≠o

print("Tama√±o de la componente gigante (rese√±as > 50):", Gc_50.number_of_nodes())

# Densidad
densidad_50 = nx.density(G_50) if G_50.number_of_nodes() > 1 else np.nan
print("Densidad del subgrafo (rese√±as > 50):", densidad_50)

# Grado promedio
if G_50.number_of_nodes() > 0:
    grados_50 = dict(G_50.degree())
    grado_prom_50 = np.mean(list(grados_50.values()))
else:
    grado_prom_50 = np.nan
print("Grado promedio (rese√±as > 50):", grado_prom_50)

# Clustering promedio
if G_50.number_of_nodes() > 1:
    clustering_prom_50 = nx.average_clustering(G_50)
else:
    clustering_prom_50 = np.nan
print("Clustering promedio (rese√±as > 50):", clustering_prom_50)

# ASP y di√°metro SOLO sobre la componente gigante del subgrafo
if Gc_50.number_of_nodes() > 1 and nx.is_connected(Gc_50):
    try:
        asp_50 = nx.average_shortest_path_length(Gc_50)
        diam_50 = nx.diameter(Gc_50)
    except nx.NetworkXError:
        asp_50 = np.nan
        diam_50 = np.nan
else:
    asp_50 = np.nan
    diam_50 = np.nan

print("ASP (componente gigante, rese√±as > 50):", asp_50)
print("Di√°metro (componente gigante, rese√±as > 50):", diam_50)

# Centralidad de grado y de cercan√≠a dentro del subgrafo
if G_50.number_of_nodes() > 0:
    c_deg_50 = nx.degree_centrality(G_50)
    c_clo_50 = nx.closeness_centrality(G_50)

    # Top 5 por grado
    top5_deg_50 = sorted(c_deg_50.items(), key=lambda x: x[1], reverse=True)[:5]
    print("\nTop 5 moteles por centralidad de grado (rese√±as > 50):")
    for n, c in top5_deg_50:
        print("-", G_50.nodes[n].get("nombre", n), "=>", c)

    # Top 5 por cercan√≠a
    top5_clo_50 = sorted(c_clo_50.items(), key=lambda x: x[1], reverse=True)[:5]
    print("\nTop 5 moteles por centralidad de cercan√≠a (rese√±as > 50):")
    for n, c in top5_clo_50:
        print("-", G_50.nodes[n].get("nombre", n), "=>", c)

# -------------------------------------------------
# 4. Grafo geogr√°fico del subgrafo (rese√±as > 50)
# -------------------------------------------------

# Posiciones geogr√°ficas de los nodos del subgrafo
pos_geo_50 = {
    n: (G_50.nodes[n]["lon"], G_50.nodes[n]["lat"])
    for n in G_50.nodes()
}

if len(pos_geo_50) > 0:
    xs = [p[0] for p in pos_geo_50.values()]
    ys = [p[1] for p in pos_geo_50.values()]
    x_min, x_max = min(xs), max(xs)
    y_min, y_max = min(ys), max(ys)

    plt.figure(figsize=(8, 8))

    # Aristas del subgrafo
    nx.draw_networkx_edges(
        G_50,
        pos_geo_50,
        edge_color="gray",
        width=1.2,
        alpha=0.8
    )

    # Nodos del subgrafo
    nx.draw_networkx_nodes(
        G_50,
        pos_geo_50,
        node_color="dodgerblue",
        node_size=80,
        edgecolors="black",
        linewidths=0.4
    )

    # (Opcional) etiquetas de nombre
    # labels_50 = {n: G_50.nodes[n].get("nombre", str(n)) for n in G_50.nodes()}
    # nx.draw_networkx_labels(G_50, pos_geo_50, labels=labels_50, font_size=7)

    plt.title(f"Subgrafo de moteles con m√°s de {umbral_rese√±as} rese√±as\n(coordenadas geogr√°ficas)")
    plt.axis("equal")
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    plt.axis("off")
    plt.show()
else:
    print("No hay nodos con m√°s de", umbral_rese√±as, "rese√±as.")
```

## ultimas

```{python}
#| colab: {base_uri: https://localhost:8080/}
list(Gc_moteles.nodes())
print(res_moteles)
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 746}
import networkx as nx
import matplotlib.pyplot as plt
import math

# ==========================================
# 1. Funci√≥n Haversine para distancia geogr√°fica
#    (resultado en kil√≥metros)
# ==========================================
def haversine_km(lat1, lon1, lat2, lon2):
    R = 6371.0  # Radio de la Tierra en km

    phi1 = math.radians(lat1)
    phi2 = math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)

    a = math.sin(dphi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2) ** 2
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    d = R * c
    return d, c  # km, radianes

# ==========================================
# 2. Asignar pesos (distancia geogr√°fica) a cada arista
# ==========================================
for u, v in Gc_moteles.edges():
    lat1 = Gc_moteles.nodes[u]["lat"]
    lon1 = Gc_moteles.nodes[u]["lon"]
    lat2 = Gc_moteles.nodes[v]["lat"]
    lon2 = Gc_moteles.nodes[v]["lon"]

    d_km, d_rad = haversine_km(lat1, lon1, lat2, lon2)
    # Usamos kil√≥metros como peso; si prefieres radianes, pon d_rad
    Gc_moteles.edges[u, v]["weight"] = d_km

# ==========================================
# 3. Definir origen y destino (CAMBIA ESTOS IDs)
# ==========================================
# Ejemplo: usa los IDs reales de tus moteles
nodo_origen = list(Gc_moteles.nodes())[17]   # <-- reemplaza por tu nodo origen
nodo_destino = list(Gc_moteles.nodes())[24] # <-- reemplaza por tu nodo destino

# ==========================================
# 4. Calcular ruta √≥ptima (Dijkstra) y distancia total
# ==========================================
ruta = nx.shortest_path(Gc_moteles, source=nodo_origen, target=nodo_destino, weight="weight")
dist_total_km = nx.shortest_path_length(Gc_moteles, source=nodo_origen, target=nodo_destino, weight="weight")

# Convertir a radianes (distancia angular equivalente)
# Distancia angular total = suma de distancias km / R
R = 6371.0
dist_total_rad = dist_total_km / R

print("Ruta √≥ptima (Dijkstra) entre nodos:")
for n in ruta:
    print("-", Gc_moteles.nodes[n].get("nombre", n))

print(f"\nDistancia total aproximada: {dist_total_km:.3f} km")
print(f"Distancia angular aproximada: {dist_total_rad:.5f} radianes")

# ==========================================
# 5. Dibujar grafo geogr√°fico con ruta √≥ptima resaltada
# ==========================================
# Posiciones geogr√°ficas
pos_geo = {
    n: (Gc_moteles.nodes[n]["lon"], Gc_moteles.nodes[n]["lat"])
    for n in Gc_moteles.nodes()
}

xs = [p[0] for p in pos_geo.values()]
ys = [p[1] for p in pos_geo.values()]
x_min, x_max = min(xs), max(xs)
y_min, y_max = min(ys), max(ys)

# Aristas de la ruta
aristas_ruta = list(zip(ruta[:-1], ruta[1:]))

plt.figure(figsize=(8, 8))

# Toda la red en gris claro
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edge_color="lightgray",
    width=0.8,
    alpha=0.7
)
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    node_color="lightgray",
    node_size=50,
    alpha=0.7
)

# Ruta √≥ptima en rojo
nx.draw_networkx_edges(
    Gc_moteles,
    pos_geo,
    edgelist=aristas_ruta,
    edge_color="red",
    width=2.5,
    alpha=0.95
)

# Nodos de la ruta en azul
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=ruta,
    node_color="dodgerblue",
    node_size=90,
    edgecolors="black",
    linewidths=0.6
)

# Extremos de la ruta en azul oscuro
nx.draw_networkx_nodes(
    Gc_moteles,
    pos_geo,
    nodelist=[nodo_origen, nodo_destino],
    node_color="navy",
    node_size=120,
    edgecolors="black",
    linewidths=0.8
)

# Etiquetas solo para los extremos (para no saturar)
labels_extremos = {
    nodo_origen: Gc_moteles.nodes[nodo_origen].get("nombre", str(nodo_origen)),
    nodo_destino: Gc_moteles.nodes[nodo_destino].get("nombre", str(nodo_destino))
}
nx.draw_networkx_labels(
    Gc_moteles,
    pos_geo,
    labels=labels_extremos,
    font_size=8,
    font_color="black"
)

plt.title("Ruta √≥ptima (Dijkstra) entre dos moteles\n(distancia geogr√°fica m√≠nima)")
plt.axis("equal")
plt.xlim(x_min, x_max)
plt.ylim(y_min, y_max)
plt.axis("off")
plt.show()
```

##Sensibilidad

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 441}
import networkx as nx
import pandas as pd
import numpy as np

# ===========================================
# 1. Grafo base (componente gigante)
# ===========================================
G = Gc_moteles.copy()

# M√©tricas iniciales
comp_inicial = nx.number_connected_components(G)
if nx.is_connected(G):
    asp_inicial = nx.average_shortest_path_length(G)
else:
    # ASP solo de componente gigante
    cc = max(nx.connected_components(G), key=len)
    asp_inicial = nx.average_shortest_path_length(G.subgraph(cc))

print("Componentes iniciales:", comp_inicial)
print("ASP inicial:", asp_inicial)

# ===========================================
# 2. Seleccionar nodos clave (top k por betweenness)
# ===========================================
k = 3  # n√∫mero de nodos clave a evaluar
betw = nx.betweenness_centrality(G, normalized=True)

top_nodos = sorted(betw, key=betw.get, reverse=True)[:k]

print("\nNodos seleccionados (betweenness):")
for n in top_nodos:
    print("-", G.nodes[n].get("nombre", n), "=>", betw[n])

# ===========================================
# 3. Funci√≥n para medir impacto tras eliminar nodo
# ===========================================
def medir_impacto(G_original, nodo):
    G2 = G_original.copy()
    G2.remove_node(nodo)

    comp_desp = nx.number_connected_components(G2)

    # ASP despu√©s (solo componente gigante)
    cc2 = max(nx.connected_components(G2), key=len)
    Gg2 = G2.subgraph(cc2).copy()

    asp_desp = nx.average_shortest_path_length(Gg2)

    return comp_desp, asp_desp

# ===========================================
# 4. Tabla de resultados
# ===========================================
filas = []

for n in top_nodos:
    comp_desp, asp_desp = medir_impacto(G, n)

    delta_comp = comp_desp - comp_inicial
    delta_asp = asp_desp - asp_inicial

    # Interpretaci√≥n autom√°tica b√°sica
    if delta_comp > 0:
        interpretacion = "Cr√≠tico: la eliminaci√≥n fragmenta la red."
    elif delta_asp > 0.15:
        interpretacion = "Nodo puente: aumenta la distancia promedio."
    else:
        interpretacion = "Redundante: impacto local m√≠nimo."

    filas.append({
        "Motel removido": G.nodes[n].get("nombre", n),
        "Comp antes": comp_inicial,
        "Comp despu√©s": comp_desp,
        "Œî Comp": delta_comp,
        "ASP antes": asp_inicial,
        "ASP despu√©s": asp_desp,
        "Œî ASP": delta_asp,
        "Interpretaci√≥n": interpretacion
    })

df_sensibilidad = pd.DataFrame(filas)
df_sensibilidad
```

