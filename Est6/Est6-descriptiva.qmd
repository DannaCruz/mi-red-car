---
title: "Est6-descriptiva"
format: html
---

```{r, message = FALSE}
library(geosphere)    # distHaversine
library(igraph)       # grafos y algoritmos
library(tidyverse)    # manipulación
library(leaflet)      # mapas interactivos
library(RColorBrewer) # paletas
library(htmlwidgets)  # saveWidget
library(scales)       # rescale
library(data.table)   # rápido cuando convenga
library(ggraph)
```

# Construccion grafo de proximidad

```{r, message = FALSE}
# -------------------------
# 1) Cargar datos (ajusta el path si hace falta)
# -------------------------
df <- read_csv("cine_data.csv", show_col_types = FALSE)

# Asegurarnos columnas y ver primeras filas
glimpse(df)
df %>% slice_head(n=6)

```


```{r}
# -------------------------
# 2) Preparar datos con lat/lon válidos
# -------------------------
df_geo <- df %>%
  filter(!is.na(lat) & !is.na(lon)) %>%
  mutate(.node = row_number())    # nodo 1..n usado en igraph

coords <- df_geo %>% select(lon, lat) %>% as.matrix()  # (lon, lat) required by geosphere
n <- nrow(df_geo)
n

```

```{r}
# -------------------------
# 3) k-NN usando distancia haversine (idéntico a sklearn NearestNeighbors(metric="haversine"))
# -------------------------
k <- 6   # el mismo que usaste en Python

# 3.1) Matriz de distancias (en metros) — ojo: para n grande puede ser pesado
dist_mat_m <- distm(coords, fun = distHaversine)  # n x n matrix
diag(dist_mat_m) <- Inf                           # evitar el self-nearest

# 3.2) Para cada fila tomar los k menores
knn_idx <- apply(dist_mat_m, 1, function(r) order(r)[1:k])  # devuelve índices (1..n)
knn_dist_m <- apply(dist_mat_m, 1, function(r) sort(r)[1:k]) # distancias en m

# Si prefieres tener matrices con filas = observaciones:
knn_idx <- t(knn_idx)       # n x k (cada fila: vecinos de i)
knn_dist_m <- t(knn_dist_m) # n x k

```




```{r}
# -------------------------
# 4) Construcción del grafo (no dirigido), con peso = distancia en km
# -------------------------
edges <- vector("list", n)  # recolectar pares i-j

edge_df <- tibble(from = integer(), to = integer(), weight_km = double())

for (i in seq_len(n)) {
  neighs <- knn_idx[i, ]
  dists_m <- knn_dist_m[i, ]
  for (jpos in seq_along(neighs)) {
    j <- neighs[jpos]
    if (i != j) {
      edge_df <- edge_df %>% add_row(from = i, to = j, weight_km = dists_m[jpos] / 1000)
    }
  }
}
# Hacer único (sin duplicados i-j y j-i)
edge_df <- edge_df %>%
  mutate(a = pmin(from,to), b = pmax(from,to)) %>%
  distinct(a,b, .keep_all = TRUE) %>%
  select(from = a, to = b, weight_km)

# Crear igraph (nodos 1..n)
G <- graph_from_data_frame(
  d = edge_df,
  directed = FALSE,
  vertices = df_geo %>% mutate(name = .node) %>% select(name, everything())
)

V(G)$name <- df_geo$name      # nombre legible
V(G)$rating <- df_geo$rating
V(G)$reviews <- df_geo$reviews
V(G)$rooms <- df_geo$rooms
V(G)$lon <- df_geo$lon
V(G)$lat <- df_geo$lat

# verificar
cat("Nodos:", vcount(G), "Aristas:", ecount(G), "\n")

```


```{r}
# -------------------------
# 5) Estadísticas básicas y centralidades
# -------------------------

n  <- vcount(G)
m  <- ecount(G)
dens <- edge_density(G)

deg <- degree(G)
deg_mean   <- mean(deg)
deg_median <- median(deg)
deg_max    <- max(deg)

# centralidades
deg_centrality <- centr_degree(G, mode="all", normalized=TRUE)$res
clo <- closeness(G, normalized = TRUE)

bet_raw <- betweenness(G, directed = FALSE)
bet_norm <- if (n >= 3) bet_raw / ((n-1)*(n-2)/2) else bet_raw

# tabla de métricas
metrics_tbl <- tibble(
  node = as.integer(V(G)),
  id = df_geo$id,
  name = V(G)$name,
  degree = deg,
  deg_centrality = deg_centrality,
  closeness = clo,
  betweenness = bet_norm,
  rating = V(G)$rating,
  reviews = V(G)$reviews
) %>% arrange(desc(betweenness))

# mostrar top-10 en Quarto
metrics_tbl %>% slice_head(n = 10)

```

Interpretación. La red cuenta con 30 nodos y 112 aristas, que generan una densidad moderada
de 0.26. El grado medio de 7.47 indica que, en promedio, cada nodo se conecta con alrededor de 7
vecinos cercanos, mientras que algunos nodos alcanzan hasta 10 conexiones, actuando como pequeños
hubs. La mediana de 7, al ser cercana a la media, muestra una distribución relativamente homogénea.

# Visualizacion del grafo 
Para ilustrar la distribución espacial de los nodos, se generó un mapa con la biblioteca
Folium en Python, centrado en Bogotá. Cada nodo se representa mediante un marcador circular cuyo color
indica la calificación promedio: verde para ≥ 4.5, naranja para 3.5–4.5 y rojo para valores menores.
Además, cada marcador muestra el nombre del establecimiento y el número de reseñas. Esta visual-
ización permite identificar zonas de alta concentración antes de analizar métricas de conectividad.

![Foto de un cine](figs/mapafolium.png)


```{r}
# -------------------------
# 6) Componentes, clustering, caminos
# -------------------------
comps <- components(G)
comp_sizes <- comps$csize
cat("Componentes:", length(comp_sizes), "tamaños:", comp_sizes, "\n")

# Subgrafo gigante (para ASP y diametro)
giant_comp_id <- which.max(comp_sizes)
giant_nodes <- which(comps$membership == giant_comp_id)
G_giant <- induced_subgraph(G, giant_nodes)

asp <- mean_distance(G_giant)
diam <- diameter(G_giant)
cat("ASP (gigante):", asp, " | Diametro:", diam, "\n")

# clustering promedio (transitivity global)
clust_prom <- transitivity(G, type = "global")
cat("Clustering promedio:", clust_prom, "\n")

```
En la red de cines, el clustering promedio es de 0.6, lo que indica que la mayoría de cines están
conectados entre sí, pero se forman clusters o microzonas de cohesión más local.


```{r}
# -------------------------
# 7) Detección de comunidades (Louvain) y modularidad
# -------------------------
if (!is_weighted(G)) {
  # igraph's cluster_louvain expects weights optionally; here usamos peso = weight_km si existe
  if ("weight_km" %in% edge_attr_names(G)) {
    E(G)$w_inv <- 1 / (E(G)$weight_km + 1e-6)
    com <- cluster_louvain(G, weights = E(G)$w_inv)
  } else {
    com <- cluster_louvain(G)
  }
} else {
  com <- cluster_louvain(G, weights = E(G)$weight_km)
}

membership <- membership(com)
Q <- modularity(com)
cat("Comunidades:", length(sizes(com)), "| Modularidad Q:", Q, "\n")

# añadir membresía a tabla
metrics_tbl <- metrics_tbl %>% mutate(community = membership)

```
Se detectaron 5 comunidades principales con un valor de Q = 0.6, lo que indica una estructura
comunitaria relativamente bien definida. Cada grupo refleja zonas de proximidad o cines que com-
parten mayor conectividad entre sí que con el resto de la red, evidenciando subestructuras locales
dentro de la red urbana de cines.

```{r}
library(knitr)

top_bet <- metrics_tbl %>%
  arrange(desc(betweenness)) %>%
  slice_head(n = 10)

kable(top_bet, caption = "Top-10 nodos por betweenness")


```

Aquellos con elevada centralidad de intermediación (betweenness) actúan como nodos puente que
conectan distintas regiones o clusters de la red. Estos nodos son críticos para la conectividad general:
su eliminación podría fragmentar la red o aumentar las distancias promedio entre cines.

```{r}
# -------------------------
# 9) Plots: distribución de grados y CDF
# -------------------------
# Histograma de grado
hist(
  deg,
  breaks = seq(min(deg)-0.5, max(deg)+0.5, by=1),
  main = "Distribución de grado — Red de cines",
  xlab = "Grado (vecinos)",
  ylab = "Frecuencia",
  col = "skyblue",
  border = "white"
)


# CDF del grado
gr_sorted <- sort(deg)
cdf <- seq_along(gr_sorted) / length(gr_sorted)

plot(
  gr_sorted, cdf,
  type = "s",
  main = "CDF del grado — Red de cines",
  xlab = "Grado",
  ylab = "Proporción acumulada"
)
grid()


```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

